<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>《Vim实用技巧（第2版）》学习笔记</title>
        <meta name="robots" content="noindex" />
        <!-- Custom HTML head -->
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">
        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">
        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="index.html">《Vim实用技巧（第2版）》学习笔记</a></li><li class="chapter-item expanded "><a href="chapter_1.html"><strong aria-hidden="true">1.</strong> 第1章-Vim解决问题的方式</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="practical_vim/c1_skill_1.html"><strong aria-hidden="true">1.1.</strong> 技巧1-认识.命令</a></li><li class="chapter-item expanded "><a href="practical_vim/c1_skill_2.html"><strong aria-hidden="true">1.2.</strong> 技巧2-不要自我重复</a></li><li class="chapter-item expanded "><a href="practical_vim/c1_skill_3.html"><strong aria-hidden="true">1.3.</strong> 技巧3-以退为进</a></li><li class="chapter-item expanded "><a href="practical_vim/c1_skill_4.html"><strong aria-hidden="true">1.4.</strong> 技巧4-执行、重复、回退</a></li><li class="chapter-item expanded "><a href="practical_vim/c1_skill_5.html"><strong aria-hidden="true">1.5.</strong> 技巧5-查找并手动替换</a></li><li class="chapter-item expanded "><a href="practical_vim/c1_skill_6.html"><strong aria-hidden="true">1.6.</strong> 技巧6-认识范式</a></li></ol></li><li class="chapter-item expanded "><a href="chapter_2.html"><strong aria-hidden="true">2.</strong> 第2章-普通模式</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="practical_vim/c2_skill_7.html"><strong aria-hidden="true">2.1.</strong> 技巧7-停顿时请移开画笔</a></li><li class="chapter-item expanded "><a href="practical_vim/c2_skill_8.html"><strong aria-hidden="true">2.2.</strong> 技巧8-把撤销单元切成块</a></li><li class="chapter-item expanded "><a href="practical_vim/c2_skill_9.html"><strong aria-hidden="true">2.3.</strong> 技巧9-构造可重复的修改</a></li><li class="chapter-item expanded "><a href="practical_vim/c2_skill_10.html"><strong aria-hidden="true">2.4.</strong> 技巧10-用次数做简单的算术运算</a></li><li class="chapter-item expanded "><a href="practical_vim/c2_skill_11.html"><strong aria-hidden="true">2.5.</strong> 技巧11-能够重复,就别用次数</a></li><li class="chapter-item expanded "><a href="practical_vim/c2_skill_12.html"><strong aria-hidden="true">2.6.</strong> 技巧12-双剑合璧，天下无敌</a></li></ol></li><li class="chapter-item expanded "><a href="chapter_3.html"><strong aria-hidden="true">3.</strong> 第3章-插入模式</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="practical_vim/c3_skill_13.html"><strong aria-hidden="true">3.1.</strong> 技巧13-在插入模式中可即时更正错误</a></li><li class="chapter-item expanded "><a href="practical_vim/c3_skill_14.html"><strong aria-hidden="true">3.2.</strong> 技巧14-返回普通模式</a></li><li class="chapter-item expanded "><a href="practical_vim/c3_skill_15.html"><strong aria-hidden="true">3.3.</strong> 技巧15-不离开插入模式，粘贴寄存器中的文本</a></li><li class="chapter-item expanded "><a href="practical_vim/c3_skill_16.html"><strong aria-hidden="true">3.4.</strong> 技巧16-随时随地地做运算</a></li><li class="chapter-item expanded "><a href="practical_vim/c3_skill_17.html"><strong aria-hidden="true">3.5.</strong> 技巧17-用字符编码插入非常用字符</a></li><li class="chapter-item expanded "><a href="practical_vim/c3_skill_18.html"><strong aria-hidden="true">3.6.</strong> 技巧18-用二合字母插入非常用字符</a></li><li class="chapter-item expanded "><a href="practical_vim/c3_skill_19.html"><strong aria-hidden="true">3.7.</strong> 技巧19-用替换模式替换已有文本</a></li></ol></li><li class="chapter-item expanded "><a href="chapter_4.html"><strong aria-hidden="true">4.</strong> 第4章-可视模式</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="practical_vim/c4_skill_20.html"><strong aria-hidden="true">4.1.</strong> 技巧20-深入理解可视模式</a></li><li class="chapter-item expanded "><a href="practical_vim/c4_skill_21.html"><strong aria-hidden="true">4.2.</strong> 技巧21-选择高亮选区</a></li><li class="chapter-item expanded "><a href="practical_vim/c4_skill_22.html"><strong aria-hidden="true">4.3.</strong> 技巧22-重复执行面向行的可视命令</a></li><li class="chapter-item expanded "><a href="practical_vim/c4_skill_23.html"><strong aria-hidden="true">4.4.</strong> 技巧23-只要可能，最好用操作符命令，而不是可视命令</a></li><li class="chapter-item expanded "><a href="practical_vim/c4_skill_24.html"><strong aria-hidden="true">4.5.</strong> 技巧24-面向列面向列块的可视模式编辑表格数据</a></li><li class="chapter-item expanded "><a href="practical_vim/c4_skill_25.html"><strong aria-hidden="true">4.6.</strong> 技巧25-修改列文本</a></li><li class="chapter-item expanded "><a href="practical_vim/c4_skill_26.html"><strong aria-hidden="true">4.7.</strong> 技巧26-在长短不一的高亮块后添加文本</a></li></ol></li><li class="chapter-item expanded "><a href="chapter_5.html"><strong aria-hidden="true">5.</strong> 第5章-命令行模式</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="practical_vim/c5_skill_27.html"><strong aria-hidden="true">5.1.</strong> 技巧27-认识Vim的命令行模式</a></li><li class="chapter-item expanded "><a href="practical_vim/c5_skill_28.html"><strong aria-hidden="true">5.2.</strong> 技巧28-在一行或多个连续行上执行命令</a></li><li class="chapter-item expanded "><a href="practical_vim/c5_skill_29.html"><strong aria-hidden="true">5.3.</strong> 技巧29-‘:t’和‘:m’复制和移动行</a></li><li class="chapter-item expanded "><a href="practical_vim/c5_skill_33.html"><strong aria-hidden="true">5.4.</strong> 技巧33-把当前单词插入命令行</a></li><li class="chapter-item expanded "><a href="practical_vim/c5_skill_34.html"><strong aria-hidden="true">5.5.</strong> 技巧34-回溯历史命令</a></li><li class="chapter-item expanded "><a href="practical_vim/c5_skill_35.html"><strong aria-hidden="true">5.6.</strong> 技巧35-运行Shell命令</a></li><li class="chapter-item expanded "><a href="practical_vim/c5_skill_36.html"><strong aria-hidden="true">5.7.</strong> 技巧36-批处理运行Ex命令</a></li></ol></li><li class="chapter-item expanded "><a href="chapter_6.html"><strong aria-hidden="true">6.</strong> 第6章-管理多个文件</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="practical_vim/c6_skill_37.html"><strong aria-hidden="true">6.1.</strong> 技巧37-批处理运行Ex命令</a></li><li class="chapter-item expanded "><a href="practical_vim/c6_skill_38.html"><strong aria-hidden="true">6.2.</strong> 技巧38-用参数列表将缓冲区分组</a></li><li class="chapter-item expanded "><a href="practical_vim/c6_skill_39.html"><strong aria-hidden="true">6.3.</strong> 技巧39-管理隐藏缓冲区</a></li><li class="chapter-item expanded "><a href="practical_vim/c6_skill_40.html"><strong aria-hidden="true">6.4.</strong> 技巧40-将工作区切分成窗口</a></li><li class="chapter-item expanded "><a href="practical_vim/c6_skill_41.html"><strong aria-hidden="true">6.5.</strong> 技巧41-用标签页将窗口分组</a></li></ol></li><li class="chapter-item expanded "><a href="chapter_7.html"><strong aria-hidden="true">7.</strong> 第7章 打开及保存文件</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="practical_vim/c7_skill_42.html"><strong aria-hidden="true">7.1.</strong> 技巧42-用:edit命令打开及保存文件</a></li><li class="chapter-item expanded "><a href="practical_vim/c7_skill_43.html"><strong aria-hidden="true">7.2.</strong> 技巧43-使用:find打开文件</a></li><li class="chapter-item expanded "><a href="practical_vim/c7_skill_44.html"><strong aria-hidden="true">7.3.</strong> 技巧44-使用netrw管理文件系统</a></li><li class="chapter-item expanded "><a href="practical_vim/c7_skill_45.html"><strong aria-hidden="true">7.4.</strong> 技巧45-把文件保存到不存在的目录中</a></li><li class="chapter-item expanded "><a href="practical_vim/c7_skill_46.html"><strong aria-hidden="true">7.5.</strong> 技巧46-以超级用户权限保存文件</a></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">8.</strong> 第8章  用动作命令在文档中移动</div></li><li><ol class="section"><li class="chapter-item expanded "><a href="practical_vim/c8_skill_47.html"><strong aria-hidden="true">8.1.</strong> 技巧47-让手指保持在本位行上</a></li><li class="chapter-item expanded "><a href="practical_vim/c8_skill_48.html"><strong aria-hidden="true">8.2.</strong> 技巧48-区分实际行与屏幕行</a></li><li class="chapter-item expanded "><a href="practical_vim/c8_skill_49.html"><strong aria-hidden="true">8.3.</strong> 技巧49-基于单词移动</a></li><li class="chapter-item expanded "><a href="practical_vim/c8_skill_50.html"><strong aria-hidden="true">8.4.</strong> 技巧50-对字符进行查找</a></li><li class="chapter-item expanded "><a href="practical_vim/c8_skill_51.html"><strong aria-hidden="true">8.5.</strong> 技巧51-通过查找进行移动</a></li><li class="chapter-item expanded "><a href="practical_vim/c8_skill_52.html"><strong aria-hidden="true">8.6.</strong> 技巧52-用精确的文本对象选择区域</a></li><li class="chapter-item expanded "><a href="practical_vim/c8_skill_53.html"><strong aria-hidden="true">8.7.</strong> 技巧53-删除周边，修改内部</a></li><li class="chapter-item expanded "><a href="practical_vim/c8_skill_54.html"><strong aria-hidden="true">8.8.</strong> 技巧54-设置位置标记，以便快速跳回</a></li><li class="chapter-item expanded "><a href="practical_vim/c8_skill_55.html"><strong aria-hidden="true">8.9.</strong> 技巧55-在匹配括号间跳转</a></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">9.</strong> 第9章 在文件间跳转</div></li><li><ol class="section"><li class="chapter-item expanded "><a href="practical_vim/c9_skill_56.html"><strong aria-hidden="true">9.1.</strong> 技巧56-遍历跳转列表</a></li><li class="chapter-item expanded "><a href="practical_vim/c9_skill_57.html"><strong aria-hidden="true">9.2.</strong> 技巧57-遍历改变列表</a></li><li class="chapter-item expanded "><a href="practical_vim/c9_skill_58.html"><strong aria-hidden="true">9.3.</strong> 技巧58-跳转到光标下的文件</a></li><li class="chapter-item expanded "><a href="practical_vim/c9_skill_59.html"><strong aria-hidden="true">9.4.</strong> 技巧59-用全局位置标记在文件间快速</a></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">10.</strong> 第10章 复制与粘贴</div></li><li><ol class="section"><li class="chapter-item expanded "><a href="practical_vim/c10_skill_60.html"><strong aria-hidden="true">10.1.</strong> 技巧60-用无名寄存器实现删除、复制与粘贴操作</a></li><li class="chapter-item expanded "><a href="practical_vim/c10_skill_61.html"><strong aria-hidden="true">10.2.</strong> 技巧61-深入理解Vim寄存器</a></li><li class="chapter-item expanded "><a href="practical_vim/c10_skill_62.html"><strong aria-hidden="true">10.3.</strong> 技巧62-用寄存器中的内容替换高亮选区的内容</a></li><li class="chapter-item expanded "><a href="practical_vim/c10_skill_63.html"><strong aria-hidden="true">10.4.</strong> 技巧63-把寄存器的内容粘贴出来</a></li><li class="chapter-item expanded "><a href="practical_vim/c10_skill_64.html"><strong aria-hidden="true">10.5.</strong> 技巧64-与系统剪贴板进行交换</a></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">11.</strong> 第11章 宏</div></li><li><ol class="section"><li class="chapter-item expanded "><a href="practical_vim/c11_skill_65.html"><strong aria-hidden="true">11.1.</strong> 技巧65-宏的读取与执行</a></li><li class="chapter-item expanded "><a href="practical_vim/c11_skill_66.html"><strong aria-hidden="true">11.2.</strong> 技巧66-规范光标位置、直达目标以及中止宏</a></li><li class="chapter-item expanded "><a href="practical_vim/c11_skill_67.html"><strong aria-hidden="true">11.3.</strong> 技巧67-加次数回放宏</a></li><li class="chapter-item expanded "><a href="practical_vim/c11_skill_68.html"><strong aria-hidden="true">11.4.</strong> 技巧68-在连续的文本行上重复修改</a></li><li class="chapter-item expanded "><a href="practical_vim/c11_skill_69.html"><strong aria-hidden="true">11.5.</strong> 技巧69-给宏追加命令</a></li><li class="chapter-item expanded "><a href="practical_vim/c11_skill_70.html"><strong aria-hidden="true">11.6.</strong> 技巧70-在一组文件中执行宏</a></li><li class="chapter-item expanded "><a href="practical_vim/c11_skill_71.html"><strong aria-hidden="true">11.7.</strong> 技巧71-用迭代求值的方式给列表编号</a></li><li class="chapter-item expanded "><a href="practical_vim/c11_skill_72.html"><strong aria-hidden="true">11.8.</strong> 技巧72-编辑宏的内容</a></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">12.</strong> 第12章 按模式匹配以及按原义匹配</div></li><li><ol class="section"><li class="chapter-item expanded "><a href="practical_vim/c12_skill_73.html"><strong aria-hidden="true">12.1.</strong> 技巧73-调整查找模式的大小写敏感性</a></li><li class="chapter-item expanded "><a href="practical_vim/c12_skill_74.html"><strong aria-hidden="true">12.2.</strong> 技巧74-按正则表达式查找时，使用\v模式开关</a></li><li class="chapter-item expanded "><a href="practical_vim/c12_skill_75.html"><strong aria-hidden="true">12.3.</strong> 技巧75-按原义查找文本时，使用\V原义开关</a></li><li class="chapter-item expanded "><a href="practical_vim/c12_skill_76.html"><strong aria-hidden="true">12.4.</strong> 技巧76-使用圆括号捕获子匹配</a></li><li class="chapter-item expanded "><a href="practical_vim/c12_skill_77.html"><strong aria-hidden="true">12.5.</strong> 技巧77-界定单词的边界</a></li><li class="chapter-item expanded "><a href="practical_vim/c12_skill_78.html"><strong aria-hidden="true">12.6.</strong> 技巧78-界定匹配的边界</a></li><li class="chapter-item expanded "><a href="practical_vim/c12_skill_79.html"><strong aria-hidden="true">12.7.</strong> 技巧79-转义问题字符</a></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">13.</strong> 第13章 查找</div></li><li><ol class="section"><li class="chapter-item expanded "><a href="practical_vim/c13_skill_80.html"><strong aria-hidden="true">13.1.</strong> 技巧80-结识查找命令</a></li><li class="chapter-item expanded "><a href="practical_vim/c13_skill_81.html"><strong aria-hidden="true">13.2.</strong> 技巧81-高亮查找匹配</a></li><li class="chapter-item expanded "><a href="practical_vim/c13_skill_82.html"><strong aria-hidden="true">13.3.</strong> 技巧82-在执行前查找当前预览第一处匹配</a></li><li class="chapter-item expanded "><a href="practical_vim/c13_skill_83.html"><strong aria-hidden="true">13.4.</strong> 技巧83-将光标偏移到查找匹配的结尾</a></li><li class="chapter-item expanded "><a href="practical_vim/c13_skill_84.html"><strong aria-hidden="true">13.5.</strong> 技巧84-对完整的查找匹配进行操作</a></li><li class="chapter-item expanded "><a href="practical_vim/c13_skill_85.html"><strong aria-hidden="true">13.6.</strong> 技巧85-利用查找历史，迭代完成复杂的模式</a></li><li class="chapter-item expanded "><a href="practical_vim/c13_skill_86.html"><strong aria-hidden="true">13.7.</strong> 技巧86-统计当前模式的匹配个数</a></li><li class="chapter-item expanded "><a href="practical_vim/c13_skill_87.html"><strong aria-hidden="true">13.8.</strong> 技巧87-查找当前高亮选区中的文本</a></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">14.</strong> 第14章 替换</div></li><li><ol class="section"><li class="chapter-item expanded "><a href="practical_vim/c14_skill_88.html"><strong aria-hidden="true">14.1.</strong> 技巧88-认识substitute命令</a></li><li class="chapter-item expanded "><a href="practical_vim/c14_skill_89.html"><strong aria-hidden="true">14.2.</strong> 技巧89-在文件范围内查找并替换每一处匹配</a></li><li class="chapter-item expanded "><a href="practical_vim/c14_skill_90.html"><strong aria-hidden="true">14.3.</strong> 技巧90-手动控制每一次替换操作</a></li><li class="chapter-item expanded "><a href="practical_vim/c14_skill_91.html"><strong aria-hidden="true">14.4.</strong> 技巧91-重用上次的查找模式</a></li><li class="chapter-item expanded "><a href="practical_vim/c14_skill_92.html"><strong aria-hidden="true">14.5.</strong> 技巧92-用寄存器的内容替换</a></li><li class="chapter-item expanded "><a href="practical_vim/c14_skill_93.html"><strong aria-hidden="true">14.6.</strong> 技巧93-重复上一次substitute命令</a></li><li class="chapter-item expanded "><a href="practical_vim/c14_skill_94.html"><strong aria-hidden="true">14.7.</strong> 技巧94-使用子匹配重排CSV文件的字段</a></li><li class="chapter-item expanded "><a href="practical_vim/c14_skill_95.html"><strong aria-hidden="true">14.8.</strong> 技巧95-在替换过程中执行算术运算</a></li><li class="chapter-item expanded "><a href="practical_vim/c14_skill_96.html"><strong aria-hidden="true">14.9.</strong> 技巧96-交换两个或更多的单词</a></li><li class="chapter-item expanded "><a href="practical_vim/c14_skill_97.html"><strong aria-hidden="true">14.10.</strong> 技巧97-在多个文件中执行查找与替换</a></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">15.</strong> 第15章 global命令</div></li><li><ol class="section"><li class="chapter-item expanded "><a href="practical_vim/c15_skill_98.html"><strong aria-hidden="true">15.1.</strong> 技巧98-认识global命令</a></li><li class="chapter-item expanded "><a href="practical_vim/c15_skill_99.html"><strong aria-hidden="true">15.2.</strong> 技巧99-删除所有包含模式的文本行</a></li><li class="chapter-item expanded "><a href="practical_vim/c15_skill_100.html"><strong aria-hidden="true">15.3.</strong> 技巧100-将TODO项收集至寄存器</a></li><li class="chapter-item expanded "><a href="practical_vim/c15_skill_101.html"><strong aria-hidden="true">15.4.</strong> 技巧101 将CSS文件中所有规则的属性按字母排序</a></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">16.</strong> 第16章 通过ctags建立索引，并用其浏览源代码</div></li><li><ol class="section"><li class="chapter-item expanded "><a href="practical_vim/c16_skill_102.html"><strong aria-hidden="true">16.1.</strong> 技巧102-认识ctags</a></li><li class="chapter-item expanded "><a href="practical_vim/c16_skill_103.html"><strong aria-hidden="true">16.2.</strong> 技巧103-配置Vim使用ctags</a></li><li class="chapter-item expanded "><a href="practical_vim/c16_skill_104.html"><strong aria-hidden="true">16.3.</strong> 技巧104-使用Vim的标签跳转命令，浏览关键字的定义</a></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">17.</strong> 第17章 编译代码，并通过Quickfix列表浏览错误信息</div></li><li><ol class="section"><li class="chapter-item expanded "><a href="practical_vim/c17_skill_105.html"><strong aria-hidden="true">17.1.</strong> 技巧105-不用离开Vim也能编译代码</a></li><li class="chapter-item expanded "><a href="practical_vim/c17_skill_106.html"><strong aria-hidden="true">17.2.</strong> 技巧106-浏览Quickfix列表</a></li><li class="chapter-item expanded "><a href="practical_vim/c17_skill_107.html"><strong aria-hidden="true">17.3.</strong> 技巧107-回溯以前的Quickfix列表</a></li><li class="chapter-item expanded "><a href="practical_vim/c17_skill_108.html"><strong aria-hidden="true">17.4.</strong> 技巧108-定制外部编译器</a></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">18.</strong> 第18章 通过grep、vimgrep以及其他工具对整个工程进行查找</div></li><li><ol class="section"><li class="chapter-item expanded "><a href="practical_vim/c18_skill_109.html"><strong aria-hidden="true">18.1.</strong> 技巧109-不必离开Vim也能调用grep</a></li><li class="chapter-item expanded "><a href="practical_vim/c18_skill_110.html"><strong aria-hidden="true">18.2.</strong> 技巧110-定制grep程序</a></li><li class="chapter-item expanded "><a href="practical_vim/c18_skill_111.html"><strong aria-hidden="true">18.3.</strong> 技巧111-使用Vim内置的正则表达式引擎的Grep</a></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">19.</strong> 第19章 自动补全</div></li><li><ol class="section"><li class="chapter-item expanded "><a href="practical_vim/c19_skill_112.html"><strong aria-hidden="true">19.1.</strong> 技巧112-认识Vim的关键字自动补全</a></li><li class="chapter-item expanded "><a href="practical_vim/c19_skill_113.html"><strong aria-hidden="true">19.2.</strong> 技巧113-与自动补全的弹出式菜单进行交互</a></li><li class="chapter-item expanded "><a href="practical_vim/c19_skill_114.html"><strong aria-hidden="true">19.3.</strong> 技巧114-掌握关键字的来龙去脉</a></li><li class="chapter-item expanded "><a href="practical_vim/c19_skill_115.html"><strong aria-hidden="true">19.4.</strong> 技巧115-使用字典中的单词进行自动补全</a></li><li class="chapter-item expanded "><a href="practical_vim/c19_skill_116.html"><strong aria-hidden="true">19.5.</strong> 技巧116-自动补全整行文本</a></li><li class="chapter-item expanded "><a href="practical_vim/c19_skill_117.html"><strong aria-hidden="true">19.6.</strong> 技巧117-自动补全单词序列</a></li><li class="chapter-item expanded "><a href="practical_vim/c19_skill_118.html"><strong aria-hidden="true">19.7.</strong> 技巧118-自动补全文件名</a></li><li class="chapter-item expanded "><a href="practical_vim/c19_skill_119.html"><strong aria-hidden="true">19.8.</strong> 技巧119-根据上下文自动补全</a></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">20.</strong> 第20章 利用Vim的拼写检查器，查找并更正拼写错误</div></li><li><ol class="section"><li class="chapter-item expanded "><a href="practical_vim/c20_skill_120.html"><strong aria-hidden="true">20.1.</strong> 技巧120-对你的工作进行拼写检查</a></li><li class="chapter-item expanded "><a href="practical_vim/c20_skill_121.html"><strong aria-hidden="true">20.2.</strong> 技巧121-使用其他拼写字典</a></li><li class="chapter-item expanded "><a href="practical_vim/c20_skill_122.html"><strong aria-hidden="true">20.3.</strong> 技巧122-将单词添加到拼写文件中</a></li><li class="chapter-item expanded "><a href="practical_vim/c20_skill_123.html"><strong aria-hidden="true">20.4.</strong> 技巧123-在插入模式下更正拼写错误</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">《Vim实用技巧（第2版）》学习笔记</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="vim实用技巧第2版学习笔记"><a class="header" href="#vim实用技巧第2版学习笔记">《Vim实用技巧（第2版）》学习笔记</a></h1>
<h3 id="第1章-vim解决问题的方式"><a class="header" href="#第1章-vim解决问题的方式">第1章 Vim解决问题的方式</a></h3>
<ul>
<li><a href="practical_vim/c1_skill_1.html">技巧1-认识.命令</a></li>
<li><a href="practical_vim/c1_skill_2.html">技巧2-不要自我重复</a></li>
<li><a href="practical_vim/c1_skill_3.html">技巧3-以退为进</a></li>
<li><a href="practical_vim/c1_skill_4.html">技巧4-执行、重复、回退</a></li>
<li><a href="practical_vim/c1_skill_5.html">技巧5-查找并手动替换</a></li>
<li><a href="practical_vim/c1_skill_6.html">技巧6-认识.范式</a></li>
</ul>
<hr />
<h2 id="第一部分-模式"><a class="header" href="#第一部分-模式">第一部分 模式</a></h2>
<h3 id="第2章-普通模式"><a class="header" href="#第2章-普通模式">第2章 普通模式</a></h3>
<ul>
<li><a href="practical_vim/c2_skill_7.html">技巧7-停顿时请移开画笔</a></li>
<li><a href="practical_vim/c2_skill_8.html">技巧8-把撤销单元切成块</a></li>
<li><a href="practical_vim/c2_skill_9.html">技巧9-构造可重复的修改</a></li>
<li><a href="practical_vim/c2_skill_10.html">技巧10-用次数做简单的算术运算</a></li>
<li><a href="practical_vim/c2_skill_11.html">技巧11-能够重复,就别用次数</a></li>
<li><a href="practical_vim/c2_skill_12.html">技巧12-双剑合璧，天下无敌</a></li>
</ul>
<hr />
<h3 id="第3章-插入模式"><a class="header" href="#第3章-插入模式">第3章 插入模式</a></h3>
<ul>
<li><a href="practical_vim/c3_skill_13.html">技巧13-在插入模式中可即时更正错误</a></li>
<li><a href="practical_vim/c3_skill_14.html">技巧14-返回普通模式</a></li>
<li><a href="practical_vim/c3_skill_15.html">技巧15-不离开插入模式，粘贴寄存器中的文本</a></li>
<li><a href="practical_vim/c3_skill_16.html">技巧16-随时随地地做运算</a></li>
<li><a href="practical_vim/c3_skill_17.html">技巧17-用字符编码插入非常用字符</a></li>
<li><a href="practical_vim/c3_skill_18.html">技巧18-用二合字母插入非常用字符</a></li>
<li><a href="practical_vim/c3_skill_19.html">技巧19-用替换模式替换已有文本</a></li>
</ul>
<hr />
<h3 id="第4章-可视模式"><a class="header" href="#第4章-可视模式">第4章 可视模式</a></h3>
<ul>
<li><a href="practical_vim/c4_skill_20.html">技巧20-深入理解可视模式</a></li>
<li><a href="practical_vim/c4_skill_21.html">技巧21-选择高亮选区</a></li>
<li><a href="practical_vim/c4_skill_22.html">技巧22-重复执行面向行的可视命令</a></li>
<li><a href="practical_vim/c4_skill_23.html">技巧23-只要可能，最好用操作符命令，而不是可视命令</a></li>
<li><a href="practical_vim/c4_skill_24.html">技巧24-面向列面向列块的可视模式编辑表格数据</a></li>
<li><a href="practical_vim/c4_skill_25.html">技巧25-修改列文本</a></li>
<li><a href="practical_vim/c4_skill_26.html">技巧26-在长短不一的高亮块后添加文本</a></li>
</ul>
<hr />
<h3 id="第5章-命令行模式"><a class="header" href="#第5章-命令行模式">第5章 命令行模式</a></h3>
<ul>
<li><a href="practical_vim/c5_skill_27.html">技巧27-认识Vim的命令行模式</a></li>
<li><a href="practical_vim/c5_skill_28.html">技巧28-在一行或多个连续行上执行命令</a></li>
<li><a href="practical_vim/c5_skill_29.html">技巧29-29 ‘:t’和‘:m’复制和移动行</a></li>
</ul>
<ul>
<li>技巧30- 在指定范围上执行普通模式命令
<ul>
<li>如果想在一系列连续行上执行一条普通模式命令，可以用:normal命令。</li>
<li>:normal命令与.命令结合能完成大量重复性任务。</li>
<li>:%normal A; Vim在文件每行的结尾都添加一个分号。</li>
<li>:%normal i// 注释整个文件。</li>
</ul>
</li>
<li>技巧31-重复上次的Ex命令
<ul>
<li>.命令可以重复上次的普通模式命令。</li>
<li>@:重复上次的Ex命令。</li>
<li>:bn在列表中逐项正向移动。</li>
<li>:bp在列表中逐项反向移动。</li>
</ul>
</li>
<li>技巧32-自动补全Ex命令
<ul>
<li><C-d> Vim显示可用的补全列表。</li>
<li>Tab 依次遍历剩余的补全项。 </li>
</ul>
</li>
<li><a href="https://blog.csdn.net/cfanzp/article/details/122798192">技巧33-把当前单词插入命令行</a></li>
<li><a href="https://blog.csdn.net/cfanzp/article/details/122798930">技巧34-回溯历史命令</a></li>
<li><a href="https://blog.csdn.net/cfanzp/article/details/122800109">技巧35-运行Shell命令</a></li>
<li><a href="https://blog.csdn.net/cfanzp/article/details/122800651">技巧36-批处理运行Ex命令</a></li>
</ul>
<hr />
<h2 id="第二部分-文件"><a class="header" href="#第二部分-文件">第二部分 文件</a></h2>
<h3 id="第6章-管理多个文件"><a class="header" href="#第6章-管理多个文件">第6章 管理多个文件</a></h3>
<ul>
<li><a href="https://blog.csdn.net/cfanzp/article/details/105797882">技巧37-用缓冲区列表管理打开的文件</a></li>
<li><a href="https://blog.csdn.net/cfanzp/article/details/122815113">技巧38-用参数列表将缓冲区分组</a></li>
<li><a href="https://blog.csdn.net/cfanzp/article/details/122817807">技巧39-管理隐藏缓冲区</a></li>
<li><a href="https://blog.csdn.net/cfanzp/article/details/122834748?spm=1001.2014.3001.5502">技巧40-将工作区切分成窗口</a></li>
<li><a href="https://blog.csdn.net/cfanzp/article/details/122853337">技巧41-用标签页将窗口分组</a></li>
</ul>
<hr />
<h3 id="第7章-打开及保存文件"><a class="header" href="#第7章-打开及保存文件">第7章 打开及保存文件</a></h3>
<ul>
<li><a href="https://blog.csdn.net/cfanzp/article/details/105798357">技巧42-用:edit命令打开及保存文件</a></li>
<li><a href="https://blog.csdn.net/cfanzp/article/details/122868662">技巧43-使用:find打开文件</a></li>
<li><a href="https://blog.csdn.net/cfanzp/article/details/122873547">技巧44-使用netrw管理文件系统</a></li>
<li><a href="https://blog.csdn.net/cfanzp/article/details/122887814">技巧45-把文件保存到不存在的目录中</a></li>
<li><a href="https://blog.csdn.net/cfanzp/article/details/122887980">技巧46-以超级用户权限保存文件</a></li>
</ul>
<hr />
<h2 id="第三部分-更快地移动及跳转"><a class="header" href="#第三部分-更快地移动及跳转">第三部分 更快地移动及跳转</a></h2>
<h3 id="第8章--用动作命令在文档中移动"><a class="header" href="#第8章--用动作命令在文档中移动">第8章  用动作命令在文档中移动</a></h3>
<ul>
<li><a href="https://blog.csdn.net/cfanzp/article/details/105796281">技巧47-让手指保持在本位行上</a></li>
<li><a href="https://blog.csdn.net/cfanzp/article/details/122892763">技巧48-区分实际行与屏幕行</a></li>
<li><a href="https://blog.csdn.net/cfanzp/article/details/122914889">技巧49-基于单词移动</a></li>
<li><a href="https://blog.csdn.net/cfanzp/article/details/122914431">技巧50-对字符进行查找</a></li>
<li><a href="https://blog.csdn.net/cfanzp/article/details/122918030">技巧51-通过查找进行移动</a></li>
<li><a href="https://blog.csdn.net/cfanzp/article/details/122922165">技巧52-用精确的文本对象选择区域</a></li>
<li><a href="https://blog.csdn.net/cfanzp/article/details/122935481?spm=1001.2014.3001.5502">技巧53-删除周边，修改内部</a></li>
<li><a href="https://blog.csdn.net/cfanzp/article/details/122935485?spm=1001.2014.3001.5502">技巧54-设置位置标记，以便快速跳回</a></li>
<li><a href="https://blog.csdn.net/cfanzp/article/details/122935488">技巧55-在匹配括号间跳转</a></li>
</ul>
<hr />
<h3 id="第9章-在文件间跳转"><a class="header" href="#第9章-在文件间跳转">第9章 在文件间跳转</a></h3>
<ul>
<li><a href="https://blog.csdn.net/cfanzp/article/details/105798528">技巧56-遍历跳转列表</a></li>
<li><a href="https://blog.csdn.net/cfanzp/article/details/122955779?spm=1001.2014.3001.5501">技巧57-遍历改变列表</a></li>
<li><a href="https://blog.csdn.net/cfanzp/article/details/122972021">技巧58-跳转到光标下的文件</a></li>
<li><a href="https://blog.csdn.net/cfanzp/article/details/122975667">技巧59-用全局位置标记在文件间快速</a></li>
</ul>
<hr />
<h2 id="第四部分-寄存器"><a class="header" href="#第四部分-寄存器">第四部分 寄存器</a></h2>
<h3 id="第10章-复制与粘贴"><a class="header" href="#第10章-复制与粘贴">第10章 复制与粘贴</a></h3>
<ul>
<li><a href="https://blog.csdn.net/cfanzp/article/details/105799078">技巧60-用无名寄存器实现删除、复制与粘贴操作</a></li>
<li><a href="https://blog.csdn.net/cfanzp/article/details/122994105?spm=1001.2014.3001.5501">技巧61-深入理解Vim寄存器</a></li>
<li><a href="https://blog.csdn.net/cfanzp/article/details/123010896">技巧62-用寄存器中的内容替换高亮选区的内容</a></li>
<li><a href="https://blog.csdn.net/cfanzp/article/details/123011027">技巧63-把寄存器的内容粘贴出来</a></li>
<li><a href="https://blog.csdn.net/cfanzp/article/details/123011081">技巧64-与系统剪贴板进行交换</a></li>
</ul>
<hr />
<h3 id="第11章-宏"><a class="header" href="#第11章-宏">第11章 宏</a></h3>
<ul>
<li><a href="https://blog.csdn.net/cfanzp/article/details/105799631">技巧65-宏的读取与执行</a></li>
<li><a href="https://blog.csdn.net/cfanzp/article/details/123016758?spm=1001.2014.3001.5502">技巧66-规范光标位置、直达目标以及中止宏</a></li>
<li><a href="https://blog.csdn.net/cfanzp/article/details/123022052?spm=1001.2014.3001.5502">技巧67-加次数回放宏</a></li>
<li><a href="https://blog.csdn.net/cfanzp/article/details/123034844">技巧68-在连续的文本行上重复修改</a></li>
<li><a href="https://blog.csdn.net/cfanzp/article/details/123037713">技巧69-给宏追加命令</a></li>
<li><a href="https://blog.csdn.net/cfanzp/article/details/123039903">技巧70-在一组文件中执行宏</a></li>
<li><a href="https://blog.csdn.net/cfanzp/article/details/123065772">技巧71-用迭代求值的方式给列表编号</a></li>
<li><a href="https://blog.csdn.net/cfanzp/article/details/123065793">技巧72-编辑宏的内容</a></li>
</ul>
<hr />
<h2 id="第五部分-模式"><a class="header" href="#第五部分-模式">第五部分 模式</a></h2>
<h3 id="第12章-按模式匹配以及按原义匹配"><a class="header" href="#第12章-按模式匹配以及按原义匹配">第12章 按模式匹配以及按原义匹配</a></h3>
<ul>
<li><a href="https://blog.csdn.net/cfanzp/article/details/105800013">技巧73-调整查找模式的大小写敏感性 学习笔记</a></li>
<li><a href="https://blog.csdn.net/cfanzp/article/details/123081754">技巧74-按正则表达式查找时，使用\v模式开关 学习笔记</a></li>
<li><a href="https://blog.csdn.net/cfanzp/article/details/123170804?spm=1001.2014.3001.5502">技巧75-按原义查找文本时，使用\V原义开关 学习笔记</a></li>
<li><a href="https://blog.csdn.net/cfanzp/article/details/123215153">技巧76-使用圆括号捕获子匹配 学习笔记</a></li>
<li><a href="https://blog.csdn.net/cfanzp/article/details/123215803">技巧77-界定单词的边界 学习笔记</a></li>
<li><a href="https://blog.csdn.net/cfanzp/article/details/123307209?spm=1001.2014.3001.5502">技巧78-界定匹配的边界 学习笔记</a></li>
<li><a href="https://blog.csdn.net/cfanzp/article/details/123308136">技巧79-转义问题字符 学习笔记</a></li>
</ul>
<hr />
<h3 id="第13章-查找"><a class="header" href="#第13章-查找">第13章 查找</a></h3>
<ul>
<li><a href="https://blog.csdn.net/cfanzp/article/details/105795781">技巧80-结识查找命令</a></li>
<li><a href="https://blog.csdn.net/cfanzp/article/details/123316372?spm=1001.2014.3001.5502">技巧81-高亮查找匹配 学习笔记</a></li>
<li><a href="https://blog.csdn.net/cfanzp/article/details/123316393">技巧82-在执行前查找当前预览第一处匹配 学习笔记</a></li>
<li><a href="https://blog.csdn.net/cfanzp/article/details/123339111?spm=1001.2014.3001.5502">技巧83-将光标偏移到查找匹配的结尾 学习笔记</a></li>
<li><a href="https://blog.csdn.net/cfanzp/article/details/123339213">技巧84-对完整的查找匹配进行操作 学习笔记</a></li>
<li><a href="https://blog.csdn.net/cfanzp/article/details/123339316">技巧85-利用查找历史，迭代完成复杂的模式 学习笔记</a></li>
<li><a href="https://blog.csdn.net/cfanzp/article/details/123339398">技巧86-统计当前模式的匹配个数 学习笔记</a></li>
<li><a href="https://blog.csdn.net/cfanzp/article/details/123339717">技巧87-查找当前高亮选区中的文本 学习笔记</a></li>
</ul>
<hr />
<h3 id="第14章-替换"><a class="header" href="#第14章-替换">第14章 替换</a></h3>
<ul>
<li><a href="https://blog.csdn.net/cfanzp/article/details/105796493">技巧88-认识substitute命令</a></li>
<li><a href="https://blog.csdn.net/cfanzp/article/details/123363488?spm=1001.2014.3001.5502">技巧89-在文件范围内查找并替换每一处匹配</a></li>
<li><a href="https://blog.csdn.net/cfanzp/article/details/123363517?spm=1001.2014.3001.5502">技巧90-手动控制每一次替换操作</a></li>
<li><a href="https://blog.csdn.net/cfanzp/article/details/123363555?spm=1001.2014.3001.5502">技巧91-重用上次的查找模式</a></li>
<li><a href="https://blog.csdn.net/cfanzp/article/details/123363717?spm=1001.2014.3001.5502">技巧92-用寄存器的内容替换</a></li>
<li><a href="https://blog.csdn.net/cfanzp/article/details/123389016?spm=1001.2014.3001.5502">技巧93-重复上一次substitute命令</a></li>
<li><a href="https://blog.csdn.net/cfanzp/article/details/123389040?spm=1001.2014.3001.5502">技巧94-使用子匹配重排CSV文件的字段</a></li>
<li><a href="https://blog.csdn.net/cfanzp/article/details/123409043?spm=1001.2014.3001.5502">技巧95-在替换过程中执行算术运算</a></li>
<li><a href="https://blog.csdn.net/cfanzp/article/details/123409116">技巧96-交换两个或更多的单词</a></li>
<li><a href="https://blog.csdn.net/cfanzp/article/details/123409158">技巧97-在多个文件中执行查找与替换</a></li>
</ul>
<hr />
<h3 id="第15章-global命令"><a class="header" href="#第15章-global命令">第15章 global命令</a></h3>
<ul>
<li><a href="https://blog.csdn.net/cfanzp/article/details/105800329">技巧98-认识global命令</a></li>
<li><a href="https://blog.csdn.net/cfanzp/article/details/123410920">技巧99-删除所有包含模式的文本行</a></li>
<li><a href="https://blog.csdn.net/cfanzp/article/details/123411028">技巧100-将TODO项收集至寄存器</a></li>
<li><a href="https://blog.csdn.net/cfanzp/article/details/123411131">技巧101 将CSS文件中所有规则的属性按字母排序</a></li>
</ul>
<hr />
<h2 id="第六部分-工具"><a class="header" href="#第六部分-工具">第六部分 工具</a></h2>
<h3 id="第16章-通过ctags建立索引并用其浏览源代码"><a class="header" href="#第16章-通过ctags建立索引并用其浏览源代码">第16章 通过ctags建立索引，并用其浏览源代码</a></h3>
<ul>
<li><a href="https://blog.csdn.net/cfanzp/article/details/105808538">技巧102-认识ctags</a></li>
<li><a href="https://blog.csdn.net/cfanzp/article/details/123411740">技巧103-配置Vim使用ctags</a></li>
<li><a href="https://blog.csdn.net/cfanzp/article/details/123411825">技巧104-使用Vim的标签跳转命令，浏览关键字的定义</a></li>
</ul>
<hr />
<h3 id="第17章-编译代码并通过quickfix列表浏览错误信息"><a class="header" href="#第17章-编译代码并通过quickfix列表浏览错误信息">第17章 编译代码，并通过Quickfix列表浏览错误信息</a></h3>
<ul>
<li><a href="https://blog.csdn.net/cfanzp/article/details/105809199">技巧105-不用离开Vim也能编译代码</a></li>
<li><a href="https://blog.csdn.net/cfanzp/article/details/123432628">技巧106-浏览Quickfix列表</a></li>
<li><a href="https://blog.csdn.net/cfanzp/article/details/123432684">技巧107-回溯以前的Quickfix列表</a></li>
<li><a href="https://blog.csdn.net/cfanzp/article/details/123432817">技巧108-定制外部编译器</a></li>
</ul>
<hr />
<h3 id="第18章-通过grepvimgrep以及其他工具对整个工程进行查找"><a class="header" href="#第18章-通过grepvimgrep以及其他工具对整个工程进行查找">第18章 通过grep、vimgrep以及其他工具对整个工程进行查找</a></h3>
<ul>
<li><a href="https://blog.csdn.net/cfanzp/article/details/105809625">技巧109-不必离开Vim也能调用grep</a></li>
<li><a href="https://blog.csdn.net/cfanzp/article/details/123437824">技巧110-定制grep程序</a></li>
<li><a href="https://blog.csdn.net/cfanzp/article/details/123437829">技巧111-使用Vim内置的正则表达式引擎的Grep</a></li>
</ul>
<hr />
<h3 id="第19章-自动补全"><a class="header" href="#第19章-自动补全">第19章 自动补全</a></h3>
<ul>
<li><a href="https://blog.csdn.net/cfanzp/article/details/105800711">技巧112-认识Vim的关键字自动补全</a></li>
<li><a href="https://blog.csdn.net/cfanzp/article/details/123437835">技巧113-与自动补全的弹出式菜单进行交互</a></li>
<li><a href="https://blog.csdn.net/cfanzp/article/details/123437839">技巧114-掌握关键字的来龙去脉</a></li>
<li><a href="https://blog.csdn.net/cfanzp/article/details/123437863">技巧115-使用字典中的单词进行自动补全</a></li>
<li><a href="https://blog.csdn.net/cfanzp/article/details/123437874">技巧116-自动补全整行文本</a></li>
<li><a href="https://blog.csdn.net/cfanzp/article/details/123437884">技巧117-自动补全单词序列</a></li>
<li><a href="https://blog.csdn.net/cfanzp/article/details/123437889">技巧118-自动补全文件名</a></li>
<li><a href="https://blog.csdn.net/cfanzp/article/details/123437893">技巧119-根据上下文自动补全</a></li>
</ul>
<hr />
<h3 id="第20章-利用vim的拼写检查器查找并更正拼写错误"><a class="header" href="#第20章-利用vim的拼写检查器查找并更正拼写错误">第20章 利用Vim的拼写检查器，查找并更正拼写错误</a></h3>
<ul>
<li><a href="https://blog.csdn.net/cfanzp/article/details/105810148">技巧120-对你的工作进行拼写检查</a></li>
<li><a href="https://blog.csdn.net/cfanzp/article/details/123437896">技巧121-使用其他拼写字典</a></li>
<li><a href="https://blog.csdn.net/cfanzp/article/details/123437908">技巧122-将单词添加到拼写文件中</a></li>
<li><a href="https://blog.csdn.net/cfanzp/article/details/123437916">技巧123-在插入模式下更正拼写错误</a></li>
</ul>
<hr />
<h3 id="第21章-接下来干什么"><a class="header" href="#第21章-接下来干什么">第21章 接下来干什么</a></h3>
<ul>
<li>21.1 继续练习</li>
<li>21.2 定制你自己的Vim</li>
<li>12.3 欲善其事，先利其器</li>
</ul>
<hr />
<h2 id="附录-a-根据个人喜好定制vim"><a class="header" href="#附录-a-根据个人喜好定制vim">附录 A 根据个人喜好定制Vim</a></h2>
<ul>
<li>A.1 动态改变Vim的设置项</li>
<li>A.2 将配置信息存至vimrc文件</li>
<li>A.3 为特定类型的文件应用个性化设置</li>
</ul>
<h3 id="未完待续"><a class="header" href="#未完待续">未完待续…</a></h3>
<ul>
<li><a href="https://cfanzp.com">返回</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h3 id="第1章-vim解决问题的方式-1"><a class="header" href="#第1章-vim解决问题的方式-1">第1章 Vim解决问题的方式</a></h3>
<ul>
<li><a href="practical_vim/c1_skill_1.html">技巧1-认识.命令</a></li>
<li><a href="practical_vim/c1_skill_2.html">技巧2-不要自我重复</a></li>
<li><a href="practical_vim/c1_skill_3.html">技巧3-以退为进</a></li>
<li><a href="practical_vim/c1_skill_4.html">技巧4-执行、重复、回退</a></li>
<li><a href="practical_vim/c1_skill_5.html">技巧5-查找并手动替换</a></li>
<li><a href="practical_vim/c1_skill_6.html">技巧6-认识.范式</a></li>
<li><a href="https://cfanzp.com">返回</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="vim实用技巧第2版技巧1-认识命令"><a class="header" href="#vim实用技巧第2版技巧1-认识命令">《Vim实用技巧（第2版）》技巧1-认识.命令</a></h1>
<h2 id="1-什么是命令"><a class="header" href="#1-什么是命令">1. 什么是.命令？</a></h2>
<ul>
<li>命令(点命令) 可以重复上次的修改</li>
<li>命令是Vim中的瑞士军刀</li>
<li>点命令是一个微型的宏</li>
</ul>
<h2 id="2-点命令说的重复的修改指的是什么"><a class="header" href="#2-点命令说的重复的修改指的是什么">2. 点命令说的重复的“修改”指的是什么？</a></h2>
<ul>
<li>x 删除一个字符</li>
<li>dd 删掉一行</li>
<li>&gt;G 缩进</li>
</ul>
<h2 id="3-举例"><a class="header" href="#3-举例">3. 举例</a></h2>
<ul>
<li>输入daw删除1个单词后，可以按键盘中的.来重复删除后面一个单词(. == daw) 。</li>
</ul>
<h2 id="4-点命令有什么优点"><a class="header" href="#4-点命令有什么优点">4. 点命令有什么优点？</a></h2>
<ul>
<li>点命令让可以重复的修改变得简单快捷，大大提高了输入效率。</li>
</ul>
<h2 id="5-点命令有什么优点"><a class="header" href="#5-点命令有什么优点">5. 点命令有什么优点？</a></h2>
<ul>
<li>哪些情况需要使用点命令，这个问题还需要平时练习中多思考总结。</li>
<li>如果你发现自己要在几个地方同样的小修改，就可以尝试构造你的修改，让它能够被 点命令执行。</li>
</ul>
<h2 id="相关视频"><a class="header" href="#相关视频">相关视频</a></h2>
<ul>
<li><a href="https://v.douyin.com/YFgoxnP/">看视频</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="vim实用技巧第2版技巧2-不要自我重复"><a class="header" href="#vim实用技巧第2版技巧2-不要自我重复">《Vim实用技巧（第2版）》技巧2-不要自我重复</a></h1>
<h2 id="1-减少无关的移动"><a class="header" href="#1-减少无关的移动">1. 减少无关的移动</a></h2>
<ul>
<li>在行尾添加内容：使用A而不是$a(A == $a)
<ul>
<li>用A替换$a 如果是多行操作，大大提升了.命令的效率</li>
</ul>
</li>
</ul>
<h2 id="2-一箭双雕的操作"><a class="header" href="#2-一箭双雕的操作">2. 一箭双雕的操作</a></h2>
<ul>
<li>C == c$:删除当前位置到行尾的字符并进入插入模式</li>
<li>s == cl: 删除当前字符并进入插入模式</li>
<li>S == ^C:删除当前行并进入插入模式</li>
<li>I == ^i:在行首进入插入模式</li>
<li>A == $a:在行尾进入插入模式</li>
<li>o == A&lt;CR&gt;:向上插入一行</li>
<li>O == ko:向下插入一行</li>
</ul>
<h2 id="3-总结"><a class="header" href="#3-总结">3. 总结</a></h2>
<ul>
<li>在平时使用vim的过程中可以总结一下，哪些命令可以简化，用更简单的方式操作。</li>
<li>上诉命令是作者给我们总结的一些常用快捷键，理解以后，在平时的练习中多加运用，效率定会大大提高。</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="技巧3-以退为进"><a class="header" href="#技巧3-以退为进">技巧3-以退为进</a></h1>
<h2 id="1-在一个字符前后各添加一个空格这样可以事半功倍地完成任务"><a class="header" href="#1-在一个字符前后各添加一个空格这样可以事半功倍地完成任务">1. 在一个字符前后各添加一个空格，这样可以事半功倍地完成任务。</a></h2>
<ul>
<li>操作符左右添加空格，例如：用a = b + c; 替代 a=b+c;</li>
</ul>
<h2 id="2-使修改可重复"><a class="header" href="#2-使修改可重复">2. 使修改可重复</a></h2>
<ul>
<li>把a = b+c;改成a = b + c;按下面的方法好处是可以重复操作，这样可以用.命令来重复，提高了效率。</li>
</ul>
<pre><code>f+s + &lt;Esc&gt;
</code></pre>
<h2 id="3-使移动可重复"><a class="header" href="#3-使移动可重复">3. 使移动可重复</a></h2>
<ul>
<li>使用;可以重复上次f命令查找的字符</li>
</ul>
<h2 id="4-合二为一"><a class="header" href="#4-合二为一">4. 合二为一</a></h2>
<ul>
<li>修改a = b+c+d+e; 为a = b + c + d + e;的方法为</li>
</ul>
<pre><code>f+s + &lt;Esc&gt;;.;.
</code></pre>
<h2 id="5-总结"><a class="header" href="#5-总结">5. 总结</a></h2>
<ul>
<li>技巧3主要是给了一个以退为进来构造重复操作的方法；</li>
<li>使用;可以重复上次f命令查找的字符；</li>
<li>;.结合起来能够重复查找替换的操作，能够极大提高效率；</li>
<li>点命令的威力在这里又体现出来了。</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h2 id="vim实用技巧第2版技巧4-执行重复回退"><a class="header" href="#vim实用技巧第2版技巧4-执行重复回退">《Vim实用技巧（第2版）》技巧4-执行、重复、回退</a></h2>
<h3 id="1-vim可以重复执行的每个操作以及如何回退这些命令"><a class="header" href="#1-vim可以重复执行的每个操作以及如何回退这些命令">1. Vim可以重复执行的每个操作以及如何回退这些命令</a></h3>
<div class="table-wrapper"><table><thead><tr><th>序号</th><th>目的</th><th>操作</th><th>重复</th><th>回退</th></tr></thead><tbody>
<tr><td>1</td><td>做出一个修改</td><td>{edit}</td><td>.</td><td>u</td></tr>
<tr><td>2</td><td>在行内查找下一指定字符</td><td>f{char}/t{char}</td><td>;</td><td>,</td></tr>
<tr><td>3</td><td>在行内查找上一指定字符</td><td>F{char}/T{char}</td><td>;</td><td>,</td></tr>
<tr><td>4</td><td>在文档中查找下一匹配项</td><td>/pattern<CR></td><td>n</td><td>N</td></tr>
<tr><td>5</td><td>在文档中查找上一匹配项</td><td>?pattern<CR></td><td>n</td><td>N</td></tr>
<tr><td>6</td><td>执行替换</td><td>：s/target/replacement</td><td>&amp;</td><td>u</td></tr>
<tr><td>7</td><td>执行一系列修改</td><td>qx{changes} q</td><td>@x</td><td>u</td></tr>
</tbody></table>
</div>
<h3 id="2-总结"><a class="header" href="#2-总结">2. 总结</a></h3>
<ul>
<li>这一个技巧记录了vim中可以执行的命令，如何重复和回退，记住并在平时多加练习即可。</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h2 id="vim实用技巧第2版技巧5-查找并手动替换"><a class="header" href="#vim实用技巧第2版技巧5-查找并手动替换">《Vim实用技巧（第2版）》技巧5-查找并手动替换</a></h2>
<h3 id="1-偷懒的办法无需输入就可以进行查找"><a class="header" href="#1-偷懒的办法无需输入就可以进行查找">1. 偷懒的办法：无需输入就可以进行查找</a></h3>
<ul>
<li>* 选中，n查找下一个，N查找上一个</li>
</ul>
<h3 id="2-使修改可重复-1"><a class="header" href="#2-使修改可重复-1">2. 使修改可重复</a></h3>
<ul>
<li>进入插入模式然后退出的整个过程都是一个修改，可以用.命令进行重复</li>
</ul>
<h3 id="3-合而为一"><a class="header" href="#3-合而为一">3. 合而为一</a></h3>
<ul>
<li>1和2的组合就可以实现查找替换：n.n.n.</li>
<li>可以是用:%s/a/b/gc 进行询问替换</li>
</ul>
<h3 id="4-总结"><a class="header" href="#4-总结">4. 总结</a></h3>
<ul>
<li>平时要批量替换时，用:%s/a/b/gc 进行询问替换比较多，以后可以多尝试一下用.命令试试。</li>
<li>如果你有更好的操作方法，欢迎留言一起讨论一下~</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h2 id="vim实用技巧第2版技巧6-认识范式"><a class="header" href="#vim实用技巧第2版技巧6-认识范式">《Vim实用技巧（第2版）》技巧6-认识.范式</a></h2>
<h3 id="1-回归三个-命令编辑任务"><a class="header" href="#1-回归三个-命令编辑任务">1. 回归三个 .命令编辑任务</a></h3>
<ul>
<li>技巧2:在一系列行的结尾添加分号。<a href="practical_vim/c1_skill_2.html">查看技巧2笔记</a></li>
</ul>
<pre><code>A;&lt;Esc&gt;
j.
</code></pre>
<ul>
<li>技巧3:在每个+号前后各家1个空格。<a href="practical_vim/c1_skill_3.html">查看技巧3笔记</a></li>
</ul>
<pre><code>f+
s + 
;.
</code></pre>
<ul>
<li>技巧5:把每处出现content的地方换成copy。<a href="practical_vim/c1_skill_5.html">查看技巧5笔记</a></li>
</ul>
<pre><code>* 
cwcopy
n.
</code></pre>
<h3 id="2-范式理想模式"><a class="header" href="#2-范式理想模式">2. .范式（理想模式）</a></h3>
<ul>
<li>用一次按键移动，另一次按键执行，我们把它叫做“<strong>. 范式</strong>”</li>
</ul>
<h3 id="3-总结-1"><a class="header" href="#3-总结-1">3. 总结</a></h3>
<ul>
<li>构造“.范式”， 用一次按键移动，另一次按键执行，构造重复动作，累积效率就提高了。</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h3 id="第2章-普通模式-1"><a class="header" href="#第2章-普通模式-1">第2章 普通模式</a></h3>
<ul>
<li><a href="practical_vim/c2_skill_7.html">技巧7-停顿时请移开画笔</a></li>
<li><a href="practical_vim/c2_skill_8.html">技巧8-把撤销单元切成块</a></li>
<li><a href="practical_vim/c2_skill_9.html">技巧9-构造可重复的修改</a></li>
<li><a href="practical_vim/c2_skill_10.html">技巧10-用次数做简单的算术运算</a></li>
<li><a href="practical_vim/c2_skill_11.html">技巧11-能够重复,就别用次数</a></li>
<li><a href="practical_vim/c2_skill_12.html">技巧12-双剑合璧，天下无敌</a></li>
<li><a href="https://cfanzp.com">返回</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h2 id="技巧7-停顿时请移开画笔"><a class="header" href="#技巧7-停顿时请移开画笔">技巧7-停顿时请移开画笔</a></h2>
<h3 id="普通模式"><a class="header" href="#普通模式">普通模式</a></h3>
<ul>
<li>把普通模式是Vim的自然放松状态。</li>
<li>普通模式是一种常态。</li>
<li>许多普通模式命令可以再执行时指定执行的次数，这样他们就可以被执行多次。</li>
<li>简单地重复执行一条命令，要比花时间去计算想要执行多少次更好。</li>
</ul>
<h3 id="停顿时请移开画笔"><a class="header" href="#停顿时请移开画笔">停顿时请移开画笔</a></h3>
<ul>
<li>画家再休息时不会吧画笔放在画布上。</li>
</ul>
<h3 id="总结"><a class="header" href="#总结">总结</a></h3>
<ul>
<li>技巧7 告诉我们使用vim记住不要习惯待着插入模式，上一个操作结束后马上回到普通模式。这是个习惯问题。也是提高vim输入效率必须做到的。</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h2 id="技巧8-把撤销单元切成块"><a class="header" href="#技巧8-把撤销单元切成块">技巧8-把撤销单元切成块</a></h2>
<h3 id="1在vim中我们可以自己控制撤销的粒度"><a class="header" href="#1在vim中我们可以自己控制撤销的粒度">1.在vim中我们可以自己控制撤销的粒度</a></h3>
<ul>
<li>撤销命令：u</li>
<li>u会撤销一次修改</li>
<li>一次修改：什么是一次修改呢？前面的技巧里提到了，进入插入模式到，退出插入模式的过程是一次修改。</li>
<li>我们能够控制什么时候进入插入模式，什么时候退出，进而可以控制撤销的粒度</li>
<li>退出插入模式：&lt;Esc&gt; 或Ctrl+[</li>
</ul>
<h3 id="2-让每次可撤销块-对应一次思考过程"><a class="header" href="#2-让每次可撤销块-对应一次思考过程">2. 让每次“可撤销块” 对应一次思考过程</a></h3>
<ul>
<li>每次修改最好是一个完整的操作，这样撤销也是完整的。</li>
</ul>
<h3 id="3-在插入模式中移动光标会重置修改状态"><a class="header" href="#3-在插入模式中移动光标会重置修改状态">3. 在插入模式中移动光标会重置修改状态</a></h3>
<ul>
<li>在插入模式中移动光标会重置修改状态，所有不建议在插入模式移动光标，就是说，不用在插入模式耍上下左右键了。老老实实用hjkl吧。</li>
</ul>
<h3 id="4-总结-1"><a class="header" href="#4-总结-1">4. 总结</a></h3>
<ul>
<li>这个技巧就是告诉我们再每次退出插入模式前的修改最好是一个完整修改:一个单词，一个语句，或者一个代码块等等。</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h2 id="技巧9-构造可重复的修改"><a class="header" href="#技巧9-构造可重复的修改">技巧9-构造可重复的修改</a></h2>
<h3 id="vimgolf-整个操作的vim高尔夫得分"><a class="header" href="#vimgolf-整个操作的vim高尔夫得分">VimGolf: 整个操作的Vim高尔夫得分</a></h3>
<ul>
<li>
<p>在高尔夫得分相同的情况下，选择可重复的修改作为最优方案。</p>
</li>
<li>
<p>如下面的例子：光标在h初 需要删除nigh</p>
</li>
</ul>
<pre><code>The end is nigh
</code></pre>
<ol>
<li>可以用dbx</li>
<li>可以用bdw</li>
<li>可以用daw</li>
</ol>
<ul>
<li>高尔夫得分相同，但是 daw 可以发挥.命令的重复作用，是最优方案。</li>
</ul>
<h3 id="结论"><a class="header" href="#结论">结论</a></h3>
<ul>
<li>想要利用.命令，事先常常需要进行一番周详的考虑。</li>
<li>如果你防线自己要几个地方做同样的修改，就可以尝试构造你的修改，让他们能够被.命令重复执行。</li>
<li>要识别出这类机会需要进行一定的实践，不过一旦养成了使修改可重复的习惯，你就回从Vim这里得到“奖赏”。</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h2 id="技巧10-用次数做简单的算术运算"><a class="header" href="#技巧10-用次数做简单的算术运算">技巧10-用次数做简单的算术运算</a></h2>
<ol>
<li>大多数普通模式命令可以再执行时指定次数，可以利用这个功能来做简单的算术运算。</li>
<li>&lt;C-a&gt;和&lt;C-x&gt;命令分别对数字执行加和减操作。</li>
<li>光标移到字符5上，执行10&lt;C-a&gt;就会变成15。</li>
<li>查看&lt;C-a&gt;Vim帮助文档：h ctrl-a</li>
<li>想要做如下操作该怎么办呢？ 把&quot;background-position:0px 0px&quot; 前面的0px改为-180px。</li>
</ol>
<ul>
<li>方案1：先f0查找第一个0，再i-18&lt;Esc&gt;</li>
<li>方案2：180&lt;C-x&gt;</li>
<li>方案1和方案2中,方案2里ctrl-x有查找并修改值的功能，所以可以省了f0的步骤。但是如果是要改后面的0px那么就省不了了。</li>
</ul>
<ol start="6">
<li>008 &lt;C-a&gt;后是多少？</li>
</ol>
<ul>
<li>答案是：9</li>
<li>原因：Vim默认吧0开头的数字解释为八进制。</li>
<li>可以在vimrc里面修改为十进制 set nrformats=</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h2 id="技巧11-能够重复就别用次数"><a class="header" href="#技巧11-能够重复就别用次数">技巧11-能够重复,就别用次数</a></h2>
<h3 id="1-能够重复就别用次数"><a class="header" href="#1-能够重复就别用次数">1. 能够重复，就别用次数</a></h3>
<ol>
<li>使用次数可以使按键次数变得最少，但是缺点也很明显，我们需要认真考虑次数与重复各自的优缺点。</li>
<li>例如删掉“Delete more than one word” 想把这段文字改为“Delete one word”
<ol>
<li>方案1:d2w或2dw</li>
<li>方案2:dw.</li>
<li>方案1与方案2相比，方案2具有更细的粒度。</li>
<li>如果要删除7个单词是用哪个方案呢？ 显然方案1需要先在脑子里面计算，数一数，再按键，方案2就不需要操心。</li>
</ol>
</li>
</ol>
<h3 id="2-只在必要时使用数字"><a class="header" href="#2-只在必要时使用数字">2. 只在必要时使用数字</a></h3>
<pre><code>1. 例如：I have a couple of questions 改为 I have some more questions 可以使用c3wsome more这个时候个人觉得用数字会更方便一些。
</code></pre>
<h3 id="3-总结-2"><a class="header" href="#3-总结-2">3. 总结</a></h3>
<pre><code>1. 个人觉得使用重复还是次数还是仁者见仁智者见智，具体情况具体分析。
2. 使用重复的好处可以将修改更加细粒度化，方便后面的变更。使用数字的好处是更加快捷，简洁。
3. 当你不知道是该用重复还是次数的时候，只要不是敲的手抖的话，可以优先考虑用重复咯^ v ^
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="vim实用技巧第2版学习笔记技巧12-双剑合璧天下无敌"><a class="header" href="#vim实用技巧第2版学习笔记技巧12-双剑合璧天下无敌">《Vim实用技巧（第2版）》学习笔记：技巧12-双剑合璧，天下无敌</a></h2>
<h3 id="1-操作符--动作命令--操作"><a class="header" href="#1-操作符--动作命令--操作">1. 操作符 + 动作命令 = 操作</a></h3>
<ul>
<li>d{motion}命令可以对一个字符、一个完整单词或一整个段落进行操作，它作用的范围是由动作命令决定的。</li>
<li>c{motion},y{motion}等被统称为操作符(operator)</li>
<li>g、gu、gU命令要用两次按键来调用，g被当做前缀字符，用以改变其后面的按键行为。</li>
<li>Vim的语法只有一条额外规则，即：当一个操作符命令被连续调用2次时，他会作用于当前行。例如：</li>
</ul>
<div class="table-wrapper"><table><thead><tr><th>序号</th><th style="text-align: left">命令</th><th style="text-align: left">用途</th></tr></thead><tbody>
<tr><td>1</td><td style="text-align: left">dd</td><td style="text-align: left">删除当前行</td></tr>
<tr><td>2</td><td style="text-align: left">cc</td><td style="text-align: left">删除当前行并进入插入模式</td></tr>
<tr><td>3</td><td style="text-align: left">yy</td><td style="text-align: left">复制当前行</td></tr>
<tr><td>4</td><td style="text-align: left">&gt;&gt;</td><td style="text-align: left">缩进当前行</td></tr>
<tr><td>5</td><td style="text-align: left">= =</td><td style="text-align: left">当前行自动缩进</td></tr>
<tr><td>6</td><td style="text-align: left">gUgU(gUU)</td><td style="text-align: left">当前行全转大写</td></tr>
<tr><td>7</td><td style="text-align: left">gugu(guu)</td><td style="text-align: left">当前行全转小写</td></tr>
<tr><td>8</td><td style="text-align: left">g~ g~(g ~ ~)</td><td style="text-align: left">当前行大小写反转</td></tr>
</tbody></table>
</div>
<ul>
<li>Vim的操作符</li>
</ul>
<div class="table-wrapper"><table><thead><tr><th style="text-align: left">命令</th><th style="text-align: left">用途</th></tr></thead><tbody>
<tr><td style="text-align: left">c</td><td style="text-align: left">修改</td></tr>
<tr><td style="text-align: left">d</td><td style="text-align: left">删除</td></tr>
<tr><td style="text-align: left">y</td><td style="text-align: left">复制到寄存器</td></tr>
<tr><td style="text-align: left">g~</td><td style="text-align: left">反转大小写</td></tr>
<tr><td style="text-align: left">gu</td><td style="text-align: left">转换为小写</td></tr>
<tr><td style="text-align: left">gU</td><td style="text-align: left">转换为大写</td></tr>
<tr><td style="text-align: left">&gt;</td><td style="text-align: left">增加缩进</td></tr>
<tr><td style="text-align: left">&lt;</td><td style="text-align: left">减少缩进</td></tr>
<tr><td style="text-align: left">=</td><td style="text-align: left">自动缩进</td></tr>
<tr><td style="text-align: left">!</td><td style="text-align: left">使用外部程序过滤{motion}所跨越的行</td></tr>
</tbody></table>
</div>
<h3 id="2-自定义操作符与已有动作命令协同工作"><a class="header" href="#2-自定义操作符与已有动作命令协同工作">2. 自定义操作符与已有动作命令协同工作</a></h3>
<ul>
<li>Tim Pope的<strong>commentary.vim</strong>,此插件为Vim支持的编程语言增添了注释以及取消注释的命令
命令 | 含义
:-- |  :--
gc{motion} | 切换指定行的注释状态
gcap | 切换当前段落的注释状态
gcG | 注释当前行到文件结尾
gcc | 注释当前行</li>
</ul>
<h3 id="3-自定义动作命令与已有操作符协同工作"><a class="header" href="#3-自定义动作命令与已有操作符协同工作">3. 自定义动作命令与已有操作符协同工作</a></h3>
<ul>
<li>Kana Natsuno 的textobj-entire插件，新增2种文本对象:ie和ae。那么gg=G 就可以用=ae替换了</li>
</ul>
<h3 id="4-操作符待决模式"><a class="header" href="#4-操作符待决模式">4. 操作符待决模式</a></h3>
<ul>
<li>在命令dw中，输入d但没有输入w的短暂时间间隔就是操作符待决模式。</li>
<li>Esc结束操作符待觉模式</li>
</ul>
<h3 id="5-总结-1"><a class="header" href="#5-总结-1">5. 总结</a></h3>
<ul>
<li>认清Vim一个<strong>操作</strong>的组成可以帮助我们理解Vim的操作原理，方便我们扩展我们的命令。</li>
<li>Vim的操作符要多练习。</li>
<li><strong>commentary.vim</strong>插件很好用，推荐安装~~</li>
<li>欢迎留言一起学习讨论！</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h3 id="第3章-插入模式-1"><a class="header" href="#第3章-插入模式-1">第3章 插入模式</a></h3>
<ul>
<li><a href="practical_vim/c3_skill_13.html">技巧13-在插入模式中可即时更正错误</a></li>
<li><a href="practical_vim/c3_skill_14.html">技巧14-返回普通模式</a></li>
<li><a href="practical_vim/c3_skill_15.html">技巧15-不离开插入模式，粘贴寄存器中的文本</a></li>
<li><a href="practical_vim/c3_skill_16.html">技巧16-随时随地地做运算</a></li>
<li><a href="practical_vim/c3_skill_17.html">技巧17-用字符编码插入非常用字符</a></li>
<li><a href="practical_vim/c3_skill_18.html">技巧18-用二合字母插入非常用字符</a></li>
<li><a href="practical_vim/c3_skill_19.html">技巧19-用替换模式替换已有文本</a></li>
<li><a href="https://cfanzp.com">返回</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="技巧13-在插入模式中可即时更正错误"><a class="header" href="#技巧13-在插入模式中可即时更正错误">技巧13-在插入模式中可即时更正错误</a></h1>
<h2 id="1-在插入模式中除了用退格键还可以用下面的命令删除光标下的字符"><a class="header" href="#1-在插入模式中除了用退格键还可以用下面的命令删除光标下的字符">1. 在插入模式中除了用退格键还可以用下面的命令删除光标下的字符。</a></h2>
<div class="table-wrapper"><table><thead><tr><th style="text-align: left">按键操作</th><th style="text-align: left">用途</th></tr></thead><tbody>
<tr><td style="text-align: left">C-h</td><td style="text-align: left">删除前一个字符(同退格键)</td></tr>
<tr><td style="text-align: left">C-w</td><td style="text-align: left">删除前一个单词</td></tr>
<tr><td style="text-align: left">C-u</td><td style="text-align: left">删除到行首</td></tr>
</tbody></table>
</div>
<h3 id="2-上面的快捷键在shell中同样适用"><a class="header" href="#2-上面的快捷键在shell中同样适用">2. 上面的快捷键在Shell中同样适用。</a></h3>
<h3 id="3-总结-3"><a class="header" href="#3-总结-3">3. 总结</a></h3>
<ul>
<li>个人觉得用C-h，C-w，C-u 比用退格键更方便高效。</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="技巧14-返回普通模式"><a class="header" href="#技巧14-返回普通模式">技巧14-返回普通模式</a></h1>
<ul>
<li>插入模式只专注于做一件事，那就是输入文字。</li>
<li>普通模式却是我们大部分时间所适用的模式。</li>
</ul>
<h2 id="1-插入模式返回普通模式的几种方式"><a class="header" href="#1-插入模式返回普通模式的几种方式">1. 插入模式返回普通模式的几种方式</a></h2>
<div class="table-wrapper"><table><thead><tr><th style="text-align: left">按键操作</th><th style="text-align: left">用途</th></tr></thead><tbody>
<tr><td style="text-align: left">Esc</td><td style="text-align: left">切换到普通模式</td></tr>
<tr><td style="text-align: left">C-[</td><td style="text-align: left">切换到普通模式</td></tr>
<tr><td style="text-align: left">C-o</td><td style="text-align: left">切换到插入-普通模式</td></tr>
</tbody></table>
</div>
<h2 id="2-结识插入-普通模式"><a class="header" href="#2-结识插入-普通模式">2. 结识插入-普通模式</a></h2>
<ul>
<li>插入-普通模式是普通模式的一个特例，他能让我们执行一次普通模式命令，在此模式中，可以执行一个普通模式命令，执行完后，马上又返回到插入模式。</li>
<li>要从插入模式切到插入-普通模式，可以按C-o</li>
<li>插入模式中，让当前行显示在窗口正中间：C-ozz</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="技巧15-不离开插入模式粘贴寄存器中的文本"><a class="header" href="#技巧15-不离开插入模式粘贴寄存器中的文本">技巧15-不离开插入模式，粘贴寄存器中的文本</a></h1>
<h2 id="不离开插入模式粘贴寄存器中的文本"><a class="header" href="#不离开插入模式粘贴寄存器中的文本">不离开插入模式，粘贴寄存器中的文本</a></h2>
<ul>
<li>yt，复制文本到专用寄存器中</li>
<li>C-r0 把复制的文本粘贴到光标所在的位置</li>
</ul>
<h3 id="对面向字符的寄存器使用c-rregister命令"><a class="header" href="#对面向字符的寄存器使用c-rregister命令">对面向字符的寄存器使用C-r{register}命令</a></h3>
<ul>
<li>如果寄存器中包含了大量的文本，屏幕的更新有些轻微的延时。</li>
<li>C-rC-p{register}命令会更智能一些，会修正任何不必要的缩进。</li>
<li>文本内容多的话，不建议使用寄存器了。</li>
</ul>
<h2 id="总结-1"><a class="header" href="#总结-1">总结</a></h2>
<ul>
<li>技巧15主要是告诉我们，在插入模式中，可以使用寄存器进行复制和粘贴。</li>
<li>具体寄存器用法再后面的技巧中会有更具体的展现。</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="技巧16-随时随地地做运算"><a class="header" href="#技巧16-随时随地地做运算">技巧16-随时随地地做运算</a></h1>
<h2 id="1-表达式寄存器"><a class="header" href="#1-表达式寄存器">1. 表达式寄存器</a></h2>
<ul>
<li>可以使用=符合知名使用表达式寄存器</li>
<li>在插入模式中使用&lt;C-r&gt;= 就可以访问表达式寄存器</li>
</ul>
<h2 id="2-表达式寄存器的作用"><a class="header" href="#2-表达式寄存器的作用">2. 表达式寄存器的作用</a></h2>
<ul>
<li>表达式寄存器可以做简单的算术运算</li>
<li>更高级的应用见技巧71(笔记后续添加)</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="技巧17-用字符编码插入非常用字符"><a class="header" href="#技巧17-用字符编码插入非常用字符">技巧17-用字符编码插入非常用字符</a></h1>
<ul>
<li>Vim可以用字符编码插入任意字符。可以很方便地输入键盘上找不到的符号。</li>
<li>插入模式输入：C-v{code} 其中{code}是要插入字符的编码。</li>
<li>Vim接受的字符编码共包含3位数字。 例如A 编码：065 输入：C-v065</li>
<li>插入编码超过3位数的字符 C-vu{code},其中code是16进制的,例如:C-vu00bf</li>
<li>查看字符编码快捷键:光标放在字符上按ga</li>
<li>文本中没有的字符如何知道字符的编码，查unicode表<a href="http://www.52unicode.com/">这里有一份</a></li>
<li>C-v字符：插入当前按的字符</li>
</ul>
<div class="table-wrapper"><table><thead><tr><th style="text-align: left">按键操作</th><th style="text-align: left">用途</th></tr></thead><tbody>
<tr><td style="text-align: left">C-v{code}</td><td style="text-align: left">以十进制字符编码插入字符</td></tr>
<tr><td style="text-align: left">C-vu{code}</td><td style="text-align: left">以十六进制字符编码插入字符</td></tr>
<tr><td style="text-align: left">C-v{nondigit}</td><td style="text-align: left">原义插入非数字字符</td></tr>
<tr><td style="text-align: left">C-k{char1}{char2}</td><td style="text-align: left">插入以二合字母{char1}{char2}表示的字符</td></tr>
</tbody></table>
</div><div style="break-before: page; page-break-before: always;"></div><h1 id="技巧18-用二合字母插入非常用字符"><a class="header" href="#技巧18-用二合字母插入非常用字符">技巧18-用二合字母插入非常用字符</a></h1>
<h2 id="二合字母digraph"><a class="header" href="#二合字母digraph">二合字母（digraph）</a></h2>
<ul>
<li>插入模式输入&lt;C-k&gt;{char1}{char2} </li>
</ul>
<h2 id="如何选择组成二合字母的两个字符"><a class="header" href="#如何选择组成二合字母的两个字符">如何选择组成二合字母的两个字符</a></h2>
<ul>
<li>:h digraphs-default 查看帮助</li>
</ul>
<h2 id="查看二合字母列表"><a class="header" href="#查看二合字母列表">查看二合字母列表</a></h2>
<ul>
<li>:digraphs 查看可用的二合字母列表</li>
<li>:h digraph-table 查看另一个更为有用的列表</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="技巧19-用替换模式替换已有文本"><a class="header" href="#技巧19-用替换模式替换已有文本">技巧19-用替换模式替换已有文本</a></h1>
<h2 id="1-替换模式"><a class="header" href="#1-替换模式">1. 替换模式</a></h2>
<ul>
<li>按 R 由普通模式进入替换模式</li>
<li>按 Esc由替换模式回普通模式</li>
</ul>
<h2 id="2-用虚拟替换模式替换制表符"><a class="header" href="#2-用虚拟替换模式替换制表符">2. 用虚拟替换模式替换制表符</a></h2>
<ul>
<li>gR 进入虚拟替换模式</li>
<li>在虚拟替换模式，制表符被当成一组空格进行处理</li>
<li>在可能的情况下，尽量使用虚拟替换模式</li>
<li>单次模式的替换模式以及虚拟替换模式， r{char}和gr{char}命令允许覆盖一个字符，之后马上又回到普通模式。</li>
<li>查看帮助输入:h r</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h3 id="第4章-可视模式-1"><a class="header" href="#第4章-可视模式-1">第4章 可视模式</a></h3>
<ul>
<li><a href="practical_vim/c4_skill_20.html">技巧20-深入理解可视模式</a></li>
<li><a href="practical_vim/c4_skill_21.html">技巧21-选择高亮选区</a></li>
<li><a href="practical_vim/c4_skill_22.html">技巧22-重复执行面向行的可视命令</a></li>
<li><a href="practical_vim/c4_skill_23.html">技巧23-只要可能，最好用操作符命令，而不是可视命令</a></li>
<li><a href="practical_vim/c4_skill_24.html">技巧24-面向列面向列块的可视模式编辑表格数据</a></li>
<li><a href="practical_vim/c4_skill_25.html">技巧25-修改列文本</a></li>
<li><a href="practical_vim/c4_skill_26.html">技巧26-在长短不一的高亮块后添加文本</a></li>
<li><a href="https://cfanzp.com">返回</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h2 id="技巧20-深入理解可视模式"><a class="header" href="#技巧20-深入理解可视模式">技巧20-深入理解可视模式</a></h2>
<h3 id="深入理解可视模式"><a class="header" href="#深入理解可视模式">深入理解可视模式</a></h3>
<ul>
<li>你已经熟悉的很多普通模式命令，在可视模式中也能完成相同的功能。</li>
<li>某些可视模式命令执行的基本功能与普通模式相同，但操作上有些细微的变化。
<ol>
<li>例如c命令的功能是一样的,都是删除指定的文本并切入到插入模式。但是，指定其操作的范围，二者的方式却不相同。</li>
<li>在普通模式中，先触发修改命令，然后使用动作命令指定其作用范围。</li>
<li>在可视模式中，要先选中选区，然后再触发命令。</li>
</ol>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h2 id="技巧21-选择高亮选区"><a class="header" href="#技巧21-选择高亮选区">技巧21-选择高亮选区</a></h2>
<h3 id="激活可视模式"><a class="header" href="#激活可视模式">激活可视模式</a></h3>
<div class="table-wrapper"><table><thead><tr><th style="text-align: left">命令</th><th style="text-align: left">用途</th></tr></thead><tbody>
<tr><td style="text-align: left">v</td><td style="text-align: left">激活面向字符的可视模式</td></tr>
<tr><td style="text-align: left">V</td><td style="text-align: left">激活面向行的可视模式</td></tr>
<tr><td style="text-align: left">Ctrl-v</td><td style="text-align: left">激活面向列块的可视模式</td></tr>
<tr><td style="text-align: left">gv</td><td style="text-align: left">选中上次的高亮选区</td></tr>
</tbody></table>
</div>
<h3 id="在可视模式间切换"><a class="header" href="#在可视模式间切换">在可视模式间切换</a></h3>
<div class="table-wrapper"><table><thead><tr><th style="text-align: left">按键操作</th><th style="text-align: left">用途</th></tr></thead><tbody>
<tr><td style="text-align: left">Esc /</td><td style="text-align: left">回到普通模式</td></tr>
<tr><td style="text-align: left">Ctrl-[</td><td style="text-align: left">回到普通模式</td></tr>
<tr><td style="text-align: left">v / V /</td><td style="text-align: left">切换到普通模式</td></tr>
<tr><td style="text-align: left">Ctrl-v</td><td style="text-align: left">切换到普通模式</td></tr>
<tr><td style="text-align: left">v</td><td style="text-align: left">切换面向字符的可视模式</td></tr>
<tr><td style="text-align: left">V</td><td style="text-align: left">切换面向行的可视模式</td></tr>
<tr><td style="text-align: left">Ctrl-v</td><td style="text-align: left">切换面向列块的可视模式</td></tr>
<tr><td style="text-align: left">o</td><td style="text-align: left">切换高亮选区的活动端</td></tr>
</tbody></table>
</div>
<h3 id="切换选区的活动端"><a class="header" href="#切换选区的活动端">切换选区的活动端</a></h3>
<ul>
<li>高亮选区的范围由其两个端点界定。</li>
<li>其中一端固定，另一端可以随光标自由移动，可以用o键来切换其活动的端点。</li>
</ul>
<h3 id="总结-2"><a class="header" href="#总结-2">总结</a></h3>
<ul>
<li>o键的切换选区的活动端使用起来非常方便，之前没有注意到有这个用法，使用起来发现会方便很多。</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h2 id="技巧22-重复执行面向行的可视命令"><a class="header" href="#技巧22-重复执行面向行的可视命令">技巧22-重复执行面向行的可视命令</a></h2>
<ul>
<li>修改一个面向行的高亮选区，然后使用.命令重复此修改。</li>
<li>当使用.命令重复对高亮选区所做的修改时，此修改会重复作用于相同范围的文本。</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h2 id="技巧23-只要可能最好用操作符命令而不是可视命令"><a class="header" href="#技巧23-只要可能最好用操作符命令而不是可视命令">技巧23-只要可能，最好用操作符命令，而不是可视命令</a></h2>
<ul>
<li>可视模式可能比Vim的普通模式操作起来更自然一些，但是有一个缺点:.命令有时候会有一些异常的表现。</li>
<li>vit: visually select inside the tag</li>
<li>把括号内的字符都转为大写:</li>
<li>step1: vi{</li>
<li>step2: U</li>
<li>step3: j.</li>
</ul>
<pre><code>   &lt;html&gt;aaaaaaaaaaaaaaaaaaaaa&lt;/html&gt;
   &lt;html&gt;bbbbbbbbbbbb&lt;/html&gt;
</code></pre>
<ul>
<li>vi{,vi(,vi[ 把括号内的字符都转为大写:</li>
<li>step1: vi{</li>
<li>step2: U</li>
</ul>
<pre><code>{Aaaaaaaaaaaaaaaa}
{bbbbbbbbbbbbbbbbbbbb}
(aaaaaaaaaaaaaaa)
[bbbbbbbbbbbbbbbbbbbb]
</code></pre>
<h3 id="使用普通模式下的操作符命令"><a class="header" href="#使用普通模式下的操作符命令">使用普通模式下的操作符命令</a></h3>
<ul>
<li>gUit,gUi{,gUi[,gUi(</li>
</ul>
<h3 id="总结-3"><a class="header" href="#总结-3">总结</a></h3>
<ul>
<li>在做一系列可重复的修改时，最好首选操作符命令，而不是可视模式命令。</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h2 id="技巧24-面向列面向列块的可视模式编辑表格数据"><a class="header" href="#技巧24-面向列面向列块的可视模式编辑表格数据">技巧24-面向列面向列块的可视模式编辑表格数据</a></h2>
<ul>
<li>使用CTRL-v进入列模式</li>
<li>使用.命令重复</li>
<li>使用x删除列</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h2 id="技巧25-修改列文本"><a class="header" href="#技巧25-修改列文本">技巧25-修改列文本</a></h2>
<ul>
<li><C-v>jje：选中要操作的选区。</li>
<li>c：删除选中选区的文字并进入插入模式。</li>
<li><Esc>：返回普通模式。</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="技巧26-在长短不一的高亮块后添加文本"><a class="header" href="#技巧26-在长短不一的高亮块后添加文本">技巧26-在长短不一的高亮块后添加文本</a></h1>
<h2 id="列块可视模式不仅限于操作方形的文本区域"><a class="header" href="#列块可视模式不仅限于操作方形的文本区域">列块可视模式不仅限于操作方形的文本区域。</a></h2>
<h2 id="在长短不一的文本后面添加分号"><a class="header" href="#在长短不一的文本后面添加分号">在长短不一的文本后面添加分号:</a></h2>
<pre><code>var foo = 1
var bar ='a'
var foobar = foo + bar
</code></pre>
<ul>
<li><C-v>jj$:选中需要修改的区域</li>
<li>A;:在选中区域后面加分号&quot;;&quot;</li>
<li><Esc>:退出插入模式返回普通模式</li>
</ul>
<h2 id="vim对i以及a键的约定"><a class="header" href="#vim对i以及a键的约定">Vim对“i”以及“a”键的约定</a></h2>
<ul>
<li>Vim对于从普通模式切换到插入模式有几个约定。</li>
<li>i:插入字符之前</li>
<li>a:插入字符之后</li>
<li>A:插入行开头</li>
<li>A:插入行尾</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h3 id="第5章-命令行模式-1"><a class="header" href="#第5章-命令行模式-1">第5章 命令行模式</a></h3>
<ul>
<li><a href="practical_vim/c5_skill_27.html">技巧27-认识Vim的命令行模式</a></li>
<li><a href="practical_vim/c5_skill_28.html">技巧28-在一行或多个连续行上执行命令</a></li>
<li><a href="practical_vim/c5_skill_29.html">技巧29-‘:t’和‘:m’复制和移动行</a></li>
</ul>
<ul>
<li>技巧30- 在指定范围上执行普通模式命令
<ul>
<li>如果想在一系列连续行上执行一条普通模式命令，可以用:normal命令。</li>
<li>:normal命令与.命令结合能完成大量重复性任务。</li>
<li>:%normal A; Vim在文件每行的结尾都添加一个分号。</li>
<li>:%normal i// 注释整个文件。</li>
</ul>
</li>
<li>技巧31-重复上次的Ex命令
<ul>
<li>.命令可以重复上次的普通模式命令。</li>
<li>@:重复上次的Ex命令。</li>
<li>:bn在列表中逐项正向移动。</li>
<li>:bp在列表中逐项反向移动。</li>
</ul>
</li>
<li>技巧32-自动补全Ex命令
<ul>
<li><C-d> Vim显示可用的补全列表。</li>
<li>Tab 依次遍历剩余的补全项。 </li>
</ul>
</li>
<li><a href="https://blog.csdn.net/cfanzp/article/details/122798192">技巧33-把当前单词插入命令行</a></li>
<li><a href="https://blog.csdn.net/cfanzp/article/details/122798930">技巧34-回溯历史命令</a></li>
<li><a href="https://blog.csdn.net/cfanzp/article/details/122800109">技巧35-运行Shell命令</a></li>
</ul>
<ul>
<li><a href="https://cfanzp.com">返回</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h2 id="技巧27-认识vim的命令行模式"><a class="header" href="#技巧27-认识vim的命令行模式">技巧27-认识Vim的命令行模式</a></h2>
<h3 id="1-命令行模式"><a class="header" href="#1-命令行模式">1. 命令行模式</a></h3>
<ul>
<li>命令行模式提示我们输入一条 Ex 命令、一个查找模式或一个表达式。</li>
<li>按下: 键时，Vim会切换到命令行模式。</li>
<li>按&lt;Esc&gt; 退回到普通模式。</li>
<li>在命令行模式中执行的命令被称为 Ex 命令。</li>
<li>可以用Ex命令读写文件(:edit 和:write)
<ul>
<li>创建新标签页(:tabnew)</li>
<li>分隔窗口(:split)</li>
<li>操作参数列表(:prev/:next)</li>
<li>操作缓冲器列表(:brev/:bnext)</li>
<li>Vim为几乎所有功能都提供了相应的Ex命令(参见:h ex-cmd-index)</li>
</ul>
</li>
</ul>
<h3 id="2-操作缓冲区文本的ex命令"><a class="header" href="#2-操作缓冲区文本的ex命令">2. 操作缓冲区文本的Ex命令</a></h3>
<div class="table-wrapper"><table><thead><tr><th style="text-align: left">命令</th><th style="text-align: left">用途</th></tr></thead><tbody>
<tr><td style="text-align: left">:[range]delete [x]</td><td style="text-align: left">删除指定范围的行[到寄存器x中]</td></tr>
<tr><td style="text-align: left">:[range]yank [x]</td><td style="text-align: left">复制指定范围的行[到寄存器x中]</td></tr>
<tr><td style="text-align: left">:[line]put [x]</td><td style="text-align: left">在指定行后粘贴寄存器x中的内容</td></tr>
<tr><td style="text-align: left">:[range]copy {address}</td><td style="text-align: left">把指定范围内的行拷贝到{address}指定的行之下</td></tr>
<tr><td style="text-align: left">:[range]move {address}</td><td style="text-align: left">把指定范围内的行移动到{address}指定的行之下</td></tr>
<tr><td style="text-align: left">:[range]join</td><td style="text-align: left">连接指定范围内的行</td></tr>
<tr><td style="text-align: left">:[range]normal {command}</td><td style="text-align: left">对指定范围内的每一行执行普通模式命令{command}</td></tr>
<tr><td style="text-align: left">:[range]substitute/{pattern}/{string}/[flags]</td><td style="text-align: left">把指定范围内出现{pattern}的地方替换为{string}</td></tr>
<tr><td style="text-align: left">:[range]global/{pattern}/[cmd}</td><td style="text-align: left">对指定范围内匹配{pattern}的所有行执行Ex命令{cmd}</td></tr>
</tbody></table>
</div>
<h3 id="3-vim命令行模式中的特殊按键"><a class="header" href="#3-vim命令行模式中的特殊按键">3. Vim命令行模式中的特殊按键</a></h3>
<ul>
<li>有些命令在插入模式和命令行模式可以通用</li>
</ul>
<div class="table-wrapper"><table><thead><tr><th style="text-align: left">命令</th><th style="text-align: left">含义</th></tr></thead><tbody>
<tr><td style="text-align: left">C-w</td><td style="text-align: left">删除到上一个单词</td></tr>
<tr><td style="text-align: left">C-u</td><td style="text-align: left">删除到行首</td></tr>
<tr><td style="text-align: left">C-v</td><td style="text-align: left">键入字符</td></tr>
<tr><td style="text-align: left">C-k</td><td style="text-align: left">键入字符</td></tr>
<tr><td style="text-align: left">C-r{register}</td><td style="text-align: left">把任意寄存器的内容插入到命令行</td></tr>
</tbody></table>
</div>
<h3 id="4-ex-命令影响范围广且距离远"><a class="header" href="#4-ex-命令影响范围广且距离远">4. Ex 命令影响范围广且距离远</a></h3>
<ul>
<li>Ex 命令拥有能够在多行上同时执行的能力。</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h2 id="技巧28-在一行或多个连续行上执行命令"><a class="header" href="#技巧28-在一行或多个连续行上执行命令">技巧28-在一行或多个连续行上执行命令</a></h2>
<ol>
<li>用行号作为地址</li>
<li>用地址指定一个范围</li>
<li>用高亮选区指定范围</li>
<li>用模式指定范围</li>
<li>用偏移对地址进行修正</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h1 id="技巧-29-t和m复制和移动行"><a class="header" href="#技巧-29-t和m复制和移动行">技巧-29 ‘:t’和‘:m’复制和移动行</a></h1>
<pre><code>:[range]copy {address}
</code></pre>
<ul>
<li>:copy命令简写为:co或:t。</li>
<li>:move可以把一行或多行移到文档的其他地方。</li>
</ul>
<h2 id="t的一些实例"><a class="header" href="#t的一些实例">:t的一些实例</a></h2>
<ul>
<li>:6t. 把第6行复制到当前行下。</li>
<li>:t6 把当前行复制到第6行下。</li>
<li>:t. 为当前行创建一个副本。</li>
<li>:t$ 把当前行复制到文本结尾。</li>
<li>:'&lt;,'&gt;t0 把高亮选中的行复制到文件开头。</li>
</ul>
<h2 id="用m-命令移动行"><a class="header" href="#用m-命令移动行">用‘:m’ 命令移动行</a></h2>
<pre><code>:[range]move {address}
</code></pre>
<ul>
<li>:move 简写为:m。</li>
<li>:'&lt;,'&gt;m$ 把高亮选中的文本移动到文件末尾。</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="技巧33-把当前单词插入命令行"><a class="header" href="#技巧33-把当前单词插入命令行">技巧33-把当前单词插入命令行</a></h1>
<ul>
<li>在Vim的命令行下，<C-r><C-w>复制光标下的单词并插入命令行。</li>
<li>:%s/<C-r><C-w>/linux/g 把光标下的单词换成linux</li>
<li>:%s/<C-r><C-a>/linux/g 把光标下的字串换成linux</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="技巧34-回溯历史命令"><a class="header" href="#技巧34-回溯历史命令">技巧34 回溯历史命令</a></h1>
<ul>
<li>Vim会记录命令行模式中执行过的命令。</li>
<li>Vim提供了2种方式回溯这些命令。用光标键回滚之前的命令或调出命令行窗口查看先前的命令。</li>
<li>按<Up>和<Down>来回溯历史命令。</li>
<li>Vim缺省会记录最后20条命令。</li>
<li>在.vimrc中添加相关配置修改记录历史命令行数</li>
</ul>
<pre><code>set history=200
</code></pre>
<ul>
<li>q: 打开Ex命令行窗口</li>
<li>q/ 打开查询命令行窗口</li>
<li><C-f> 命令行<C-f>从命令行模式切换到命令行窗口</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="技巧35-运行shell命令"><a class="header" href="#技巧35-运行shell命令">技巧35-运行Shell命令</a></h1>
<ul>
<li>不用离开Vim就能方便的调用外部程序。</li>
<li>还可以吧缓冲区的内容作为标准输入发送给一个外部命令，或者吧外部命令的标准输出倒入缓冲区里。</li>
</ul>
<h2 id="执行shell中的程序"><a class="header" href="#执行shell中的程序">执行Shell中的程序</a></h2>
<ul>
<li>
<p>在Vim的命令行模式中，给命令加一个感叹号前缀就可以调用外部程序。</p>
<ul>
<li>例如查看当前目录的内容:</li>
</ul>
<pre><code>:!ls
</code></pre>
<ul>
<li>执行一次性命令:!{cmd}</li>
<li>:shell 启动一个交互的shell会话。</li>
</ul>
<pre><code>:shell
</code></pre>
<ul>
<li>exit退出交互shell返回Vim.</li>
</ul>
<pre><code>$exit
</code></pre>
<ul>
<li>把Vim置于后台<C-z>。</li>
</ul>
<pre><code>Ctrl-z
</code></pre>
<ul>
<li>fg命令返回挂起前的状态。</li>
</ul>
<pre><code>$fg
</code></pre>
<ul>
<li>jobs查看挂起进程。</li>
</ul>
<pre><code>$ jobs
[1]  + suspended  vim README.md

</code></pre>
</li>
</ul>
<h2 id="把缓冲区内容作为标准输入或输出"><a class="header" href="#把缓冲区内容作为标准输入或输出">把缓冲区内容作为标准输入或输出</a></h2>
<ul>
<li>:read !{cmd} 命令把命令的标准输出读入到当前缓冲区中。</li>
<li>:write !{cmd} 命令把缓冲区内容作为指定{cmd}的标准输入。</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="技巧36-批处理运行ex命令"><a class="header" href="#技巧36-批处理运行ex命令">技巧36-批处理运行Ex命令</a></h1>
<ul>
<li>将需要批量执行的Ex命令保存到文件batch.vim</li>
</ul>
<pre><code>cat batch.vim
global/href/join
vglobal/href/delete
%normal A: http://vimcasts.org
</code></pre>
<ul>
<li>使用:source 命令执行batch.vim</li>
</ul>
<pre><code>:source batch.vim
</code></pre>
<ul>
<li>args 命令查看vim的参数</li>
</ul>
<pre><code>:args
</code></pre>
<ul>
<li>使用argdo批量执行命令</li>
</ul>
<pre><code>:argdo source batch.vim
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h3 id="第6章-管理多个文件-1"><a class="header" href="#第6章-管理多个文件-1">第6章 管理多个文件</a></h3>
<ul>
<li><a href="practical_vim/c6_skill_37.html">技巧37-批处理运行Ex命令</a></li>
<li><a href="https://blog.csdn.net/cfanzp/article/details/122815113">技巧38-用参数列表将缓冲区分组</a></li>
<li><a href="https://blog.csdn.net/cfanzp/article/details/122817807">技巧39-管理隐藏缓冲区</a></li>
<li><a href="https://blog.csdn.net/cfanzp/article/details/122834748?spm=1001.2014.3001.5502">技巧40-将工作区切分成窗口</a></li>
<li><a href="https://blog.csdn.net/cfanzp/article/details/122853337">技巧41-用标签页将窗口分组</a></li>
<li><a href="https://cfanzp.com">返回</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h2 id="技巧37-用缓冲区列表管理打开的文件"><a class="header" href="#技巧37-用缓冲区列表管理打开的文件">技巧37-用缓冲区列表管理打开的文件</a></h2>
<h3 id="1-了解文件与缓冲区的区别"><a class="header" href="#1-了解文件与缓冲区的区别">1. 了解文件与缓冲区的区别</a></h3>
<ul>
<li>文件存储在磁盘上，而缓冲区存在于内存中。</li>
<li>绝大多数Vim命令都是用来操作缓冲区，不过也有一些命令针对文件进行操作。</li>
</ul>
<h3 id="2-结识缓冲区列表"><a class="header" href="#2-结识缓冲区列表">2. 结识缓冲区列表</a></h3>
<ul>
<li>Vim允许同时在多个缓冲区上工作。</li>
<li>:ls 查看缓冲区列表。</li>
<li>:bnext 切换到下一个缓冲区。</li>
<li>% 符号指明哪个缓冲区在当前窗口中可见。</li>
<li># 符号则代表轮换文件 &lt;C-^&gt;可以在当前文件和轮换文件之间快速切换。</li>
</ul>
<h3 id="3-使用缓冲区列表"><a class="header" href="#3-使用缓冲区列表">3. 使用缓冲区列表</a></h3>
<div class="table-wrapper"><table><thead><tr><th style="text-align: left">命令</th><th style="text-align: left">含义</th></tr></thead><tbody>
<tr><td style="text-align: left">:bprev/bp</td><td style="text-align: left">在列表中反向移动</td></tr>
<tr><td style="text-align: left">:bnext /bn</td><td style="text-align: left">在列表中正向移动</td></tr>
<tr><td style="text-align: left">:bfirst</td><td style="text-align: left">跳到列表的开头</td></tr>
<tr><td style="text-align: left">:blast</td><td style="text-align: left">跳到列表的结尾</td></tr>
<tr><td style="text-align: left">:buffer N</td><td style="text-align: left">跳转到编号为N的缓冲区</td></tr>
<tr><td style="text-align: left">:ls</td><td style="text-align: left">查看所有缓冲区</td></tr>
<tr><td style="text-align: left">:bufdo</td><td style="text-align: left">在所有缓冲区执行 Ex 命令(参见:h bufdo)</td></tr>
<tr><td style="text-align: left">:bdelete/bd N1 N2 N3</td><td style="text-align: left">删除缓冲区N1 N2 N3</td></tr>
<tr><td style="text-align: left">:N,M bdelete/bd</td><td style="text-align: left">删除N到M编号的缓冲区</td></tr>
</tbody></table>
</div>
<h3 id="删除缓冲区"><a class="header" href="#删除缓冲区">删除缓冲区</a></h3>
<ul>
<li>bdelete</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="技巧38-用参数列表将缓冲区分组"><a class="header" href="#技巧38-用参数列表将缓冲区分组">技巧38-用参数列表将缓冲区分组</a></h1>
<ul>
<li>用:argdo命令可以在参数列表中的每个文件上执行一条Ex命令。</li>
<li>:args 查看参数列表。</li>
</ul>
<pre><code>:args {arglist}
</code></pre>
<ul>
<li>用文件名指定文件</li>
</ul>
<pre><code>:args index.html app.js
:args
[index.html] app.js
</code></pre>
<ul>
<li>用Glob模式指定文件</li>
</ul>
<pre><code>:args *.*     匹配index.html app.js
:args **/*.js 匹配app.js lib/framework.js
:args **/*.js 匹配index.html app.js lib/framework.js
</code></pre>
<ul>
<li>构造个之包含.js和.css文件，但不包含其他文件类型的参数列表。</li>
</ul>
<pre><code>:args **/*.js **/*.css
</code></pre>
<ul>
<li>用反引号结构指定文件</li>
</ul>
<pre><code>cat .chapters
a.pml
b.pml
c.pml
d.pml
:args `cat .chapters`
</code></pre>
<ul>
<li>使用参数列表</li>
</ul>
<pre><code>:args {arglist} 清空重置参数列表
:next,:prev 命令遍历参数列表中的文件。
:argdo 命令在列表中的每个缓冲区上执行同一条命令。
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="技巧39-管理隐藏缓冲区"><a class="header" href="#技巧39-管理隐藏缓冲区">技巧39-管理隐藏缓冲区</a></h1>
<ul>
<li>查看缓冲区列表</li>
</ul>
<pre><code>:ls
1 #a + &quot;README.md&quot;                    line 2 
4 %a   &quot;inject_test.lua&quot;              line 6 
</code></pre>
<ul>
<li>缓冲区列表前有一个+号，表示这个缓冲区被修改过了。</li>
</ul>
<pre><code>:ls 
1 %a + &quot;README.md&quot;                    line 2 
</code></pre>
<ul>
<li>:bnext!强制切换缓冲区（README.md切换到inject_test.lua)</li>
<li>inject_test.lua被标记为a,表示它是活动缓冲区(active)</li>
<li>README.md别标记为h,表示它是一个隐藏缓冲区(hidden)</li>
</ul>
<pre><code>:bnext!
:ls
1 #h + &quot;README.md&quot;                    line 2
4 %a   &quot;inject_test.lua&quot;              line 7 
</code></pre>
<h2 id="在退出时处理隐藏缓冲区"><a class="header" href="#在退出时处理隐藏缓冲区">在退出时处理隐藏缓冲区</a></h2>
<ul>
<li>quit退出时会提示</li>
</ul>
<pre><code>：quit
E37: No write since last change 
E162: No write since last change for buffer &quot;README.md&quot;       
Press ENTER or type command to continue
</code></pre>
<ul>
<li>按任意键后会加载第一个有改动的隐藏缓冲区。这里会加载README.md</li>
<li>:write 可以保存缓冲区,:edit!可丢弃修改,没有隐藏缓冲区时:q关闭Vim。</li>
</ul>
<pre><code>:write
:edit!
:q
</code></pre>
<ul>
<li>退出Vim不检查未保存的修改</li>
</ul>
<pre><code>qall!
</code></pre>
<ul>
<li>保存所有改动的缓冲区，无需逐个检查</li>
</ul>
<pre><code>:wall
</code></pre>
<h2 id="运行do命令前启用hidden设置"><a class="header" href="#运行do命令前启用hidden设置">运行‘：*do’命令前，启用‘hidden’设置</a></h2>
<ul>
<li>启用了'hidden'选项就可以不带末尾的感叹号来执行:next、:bnext、:cnext。</li>
</ul>
<pre><code>:argdo
:bufdo
:cfdo
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="技巧40-将工作区切分成窗口"><a class="header" href="#技巧40-将工作区切分成窗口">技巧40-将工作区切分成窗口</a></h1>
<h2 id="创建分割窗口"><a class="header" href="#创建分割窗口">创建分割窗口</a></h2>
<pre><code>&lt;C-w&gt;s 水平切分当前窗口
&lt;C-w&gt;v 垂直切分当前窗口
:sp[lit] 水平切分当前窗口
:vsp[lit] 垂直切分当前窗口
</code></pre>
<ul>
<li>将缓冲区载入活动窗口中</li>
</ul>
<pre><code>:edit {filename}
</code></pre>
<h2 id="在窗口间切换"><a class="header" href="#在窗口间切换">在窗口间切换</a></h2>
<pre><code>&lt;C-w&gt;w 在窗口间循环切换
&lt;C-w&gt;h 切换到左边的窗口
&lt;C-w&gt;j 切换到下面的窗口
&lt;C-w&gt;k 切换到上面的窗口
&lt;C-w&gt;l 切换到右边的窗口
&lt;C-w&gt;&lt;C-w&gt; 同&lt;C-w&gt;w
</code></pre>
<h2 id="关闭窗口"><a class="header" href="#关闭窗口">关闭窗口</a></h2>
<pre><code>:clo[se] 或 &lt;C-w&gt;c  关闭活动窗口
:on[ly] 或 &lt;C-w&gt;o  只保留活动窗口
</code></pre>
<h2 id="改变窗口大小及重新排列窗口"><a class="header" href="#改变窗口大小及重新排列窗口">改变窗口大小及重新排列窗口</a></h2>
<pre><code>&lt;C-w&gt;= 使用所有窗口等宽、等高
&lt;C-w&gt;_ 最大化活动窗口的高度
&lt;C-w&gt;| 最大化活动窗口的宽度
[N]&lt;C-w&gt;_ 把活动窗口的高度设为[N]行
[N]&lt;C-w&gt;| 把活动窗口的宽度设为[N]列
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="技巧41-用标签页将窗口分组"><a class="header" href="#技巧41-用标签页将窗口分组">技巧41-用标签页将窗口分组</a></h1>
<h2 id="如何使用标签页"><a class="header" href="#如何使用标签页">如何使用标签页</a></h2>
<ul>
<li>lcd</li>
</ul>
<pre><code>:lcd {path}
</code></pre>
<ul>
<li>lcd 命令设置当前窗口的本地工作目录。</li>
<li>windo lcd {path} 为所有窗口设置本地工作目录。</li>
</ul>
<pre><code>:windo lcd {path}
</code></pre>
<h2 id="打开及关闭标签页"><a class="header" href="#打开及关闭标签页">打开及关闭标签页</a></h2>
<ul>
<li>tabedit 命令可以打开一个新的标签页</li>
</ul>
<pre><code>:tabedit {filename} 或 :tabe {filename}
</code></pre>
<ul>
<li>把当前窗口移到一个新标签页中</li>
</ul>
<pre><code>&lt;C-w&gt;T
</code></pre>
<ul>
<li>查看帮助</li>
</ul>
<pre><code>:h CTRL-W_T
</code></pre>
<ul>
<li>关闭此窗口以及包含此窗口的标签页</li>
</ul>
<pre><code>:close
</code></pre>
<ul>
<li>关闭当前标签页</li>
</ul>
<pre><code>:tabclose 或 :tabc
</code></pre>
<ul>
<li>只保留活动标签页</li>
</ul>
<pre><code>：tabo[only]
</code></pre>
<ul>
<li>在标签页间切换，标号从1开始</li>
</ul>
<pre><code>{N}gt
:tabn[ext] {N}
</code></pre>
<ul>
<li>切换到下一个标签页</li>
</ul>
<pre><code>gt
:tabn[ext]
</code></pre>
<ul>
<li>切换到上一个标签页</li>
</ul>
<pre><code>gT
:tabp[revious]
</code></pre>
<h2 id="重排标签页"><a class="header" href="#重排标签页">重排标签页</a></h2>
<ul>
<li>用:tabmove [N] 命令可以重新排列标签页。</li>
<li>当[N]为0时，当前标签页会被移动到开头。</li>
<li>如果省略了[N]，当前标签页会被移动到结尾。</li>
<li>如果终端支持鼠标，或是正在使用GVim,那么也可以通过鼠标拖拽来进行重排操作(不推荐)。</li>
</ul>
<h2 id="总结-4"><a class="header" href="#总结-4">总结</a></h2>
<ul>
<li>标签页平时使用的不多。</li>
<li>如果遇到多个项目需要使用vim的情况，我通常是:</li>
<li>使用tmux开启多个pannel或session。</li>
<li>或者使用i3分屏解决。</li>
<li>开启多个terminal。</li>
<li>在i3和tmux都没有的情况，标签页是可以起到很大作用的。虽然用得不多，但是需要的时候还是可以减少不少不必要的麻烦的。</li>
</ul>
<h2 id="返回vim实用技巧第2版学习笔记汇总"><a class="header" href="#返回vim实用技巧第2版学习笔记汇总"><a href="https://blog.csdn.net/cfanzp/article/details/105745176">返回《Vim实用技巧（第2版）》学习笔记：汇总</a></a></h2>
<ul>
<li>扫描下方二维码，关注我的公众号，获取更多技术方面的知识
<img src="https://img-blog.csdnimg.cn/e59c6d074ae441d29ae9ea0c5aefbb6a.png#pic_center" alt="在这里插入图片描述" /></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h3 id="第7章-打开及保存文件-1"><a class="header" href="#第7章-打开及保存文件-1">第7章 打开及保存文件</a></h3>
<ul>
<li><a href="https://blog.csdn.net/cfanzp/article/details/105798357">技巧42-用:edit命令打开及保存文件</a></li>
<li><a href="https://blog.csdn.net/cfanzp/article/details/122868662">技巧43-使用:find打开文件</a></li>
<li><a href="https://blog.csdn.net/cfanzp/article/details/122873547">技巧44-使用netrw管理文件系统</a></li>
<li><a href="https://blog.csdn.net/cfanzp/article/details/122887814">技巧45-把文件保存到不存在的目录中</a></li>
<li><a href="https://blog.csdn.net/cfanzp/article/details/122887980">技巧46-以超级用户权限保存文件</a></li>
<li><a href="https://cfanzp.com">返回</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h2 id="技巧42-用edit命令打开及保存文件"><a class="header" href="#技巧42-用edit命令打开及保存文件">技巧42-用:edit命令打开及保存文件</a></h2>
<h3 id="1-相对于当前工作目录打开一个文件"><a class="header" href="#1-相对于当前工作目录打开一个文件">1. 相对于当前工作目录打开一个文件</a></h3>
<ul>
<li>:edit {file} 命令可以接受相对于工作目录的文件路径</li>
</ul>
<h3 id="2-相对于活动文件目录打开一个文件"><a class="header" href="#2-相对于活动文件目录打开一个文件">2. 相对于活动文件目录打开一个文件</a></h3>
<ul>
<li>:edit %:h &lt;Tab&gt; M &lt;Tab&gt;&lt;Tab&gt; </li>
<li>%符号代表活动缓冲区的完整文件路径。</li>
<li>:h 修饰符会去掉文件名，但保留路径中的其他部分(参见 :h ::h)</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="技巧43-使用find打开文件"><a class="header" href="#技巧43-使用find打开文件">技巧43-使用:find打开文件</a></h1>
<h2 id="配置path选项"><a class="header" href="#配置path选项">配置'path'选项</a></h2>
<pre><code>:set path+=app/**
</code></pre>
<ul>
<li>** 通配符会匹配app/目录下的所有子目录。</li>
<li>使用rails.vim进行只能路径管理。</li>
</ul>
<h2 id="使用find命令通过文件名查找文件"><a class="header" href="#使用find命令通过文件名查找文件">使用:find命令，通过文件名查找文件。</a></h2>
<pre><code>:find Navigation.js
</code></pre>
<ul>
<li>使用Tab</li>
</ul>
<pre><code>:find Main.js&lt;Tab&gt;
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="技巧44-使用netw管理文件系统"><a class="header" href="#技巧44-使用netw管理文件系统">技巧44-使用netw管理文件系统</a></h1>
<h2 id="结识netrw--vim原生的文件管理器"><a class="header" href="#结识netrw--vim原生的文件管理器">结识netrw--Vim原生的文件管理器</a></h2>
<ul>
<li>Vim打开当前目录</li>
</ul>
<pre><code>vim .
</code></pre>
<ul>
<li>vim返回上一级目录</li>
</ul>
<pre><code>-
或光标移动到..上按&lt;CR&gt;
</code></pre>
<ul>
<li>使用 :edit {path}命令打开文件管理器窗口</li>
</ul>
<pre><code>:edit . 或 e . 在文件管理器里打开工程的根目录。
</code></pre>
<ul>
<li>在文件管理器里打开当前目录</li>
</ul>
<pre><code>：edit %:h
</code></pre>
<ul>
<li>打开文件管理器并显示活动缓冲区所在目录</li>
</ul>
<pre><code>:Explore 或:E
</code></pre>
<ul>
<li>在一个水平切分窗口及打开文件管理器</li>
</ul>
<pre><code>:Sexplore
</code></pre>
<ul>
<li>在一个垂直切分窗口打开文件管理器</li>
</ul>
<pre><code>:Vexplore
</code></pre>
<h2 id="与分割窗口协同工作"><a class="header" href="#与分割窗口协同工作">与分割窗口协同工作</a></h2>
<ul>
<li>调出文件管理器后想返回原来正在编辑的文件</li>
</ul>
<pre><code>&lt;C-^&gt;
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="技巧45-把文件保存到不存在的目录中"><a class="header" href="#技巧45-把文件保存到不存在的目录中">技巧45-把文件保存到不存在的目录中</a></h1>
<ul>
<li>创建了一个缓冲区 a/test.md</li>
</ul>
<pre><code>:edit a/test.md
</code></pre>
<ul>
<li>如果目录a不存在保存会报错</li>
</ul>
<pre><code>:write 无法保存
</code></pre>
<ul>
<li>使用下面命令可以解决问题</li>
</ul>
<pre><code>:!mkdir -p %:h 其中%代表活动缓冲区的完整文件路径，:h修饰符会去除文件名 -p是创建不存在的中间目录。
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="技巧46-以超级用户权限保存文件"><a class="header" href="#技巧46-以超级用户权限保存文件">技巧46-以超级用户权限保存文件</a></h1>
<ul>
<li>修改一个需要sudo文件权限的文件时是无法保存的，保存的方法是:</li>
</ul>
<pre><code>vim /etc/host
:w !sudo tee % &gt; /dev/null
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><ul>
<li>只有学会让手不离开本位行就可以移动光标，才能更快地操作Vim。</li>
<li>用hjkl来移动光标。</li>
</ul>
<pre><code>h 左移一列
l 右移一列
j 下移一行
k 上移一行
</code></pre>
<h2 id="让右手待在它该在的位置上"><a class="header" href="#让右手待在它该在的位置上">让右手待在它该在的位置上</a></h2>
<ul>
<li>在Qwerty键盘上，j、k、和l键刚好在右手的食指、中指和无名指下方。</li>
<li>戒掉使用光标键的习惯。</li>
<li>可以把光标键映射为什么都不做。</li>
</ul>
<pre><code>noremap &lt;Up&gt;  &lt;Nop&gt;
noremap &lt;Down&gt;  &lt;Nop&gt;
noremap &lt;Left&gt;  &lt;Nop&gt;
noremap &lt;Right&gt;  &lt;Nop&gt;
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="技巧48-区分实际行与屏幕行"><a class="header" href="#技巧48-区分实际行与屏幕行">技巧48-区分实际行与屏幕行</a></h1>
<h2 id="wrap设置开启"><a class="header" href="#wrap设置开启">wrap设置开启</a></h2>
<ul>
<li>wrap设置开启时，每个超出窗口宽度的文本行都会被会绕显示,以爆炸呢个没有文本现实不出来。</li>
</ul>
<h2 id="启用number来查看实际行与屏幕行之间的不同"><a class="header" href="#启用number来查看实际行与屏幕行之间的不同">启用number来查看实际行与屏幕行之间的不同。</a></h2>
<h2 id="实际行与屏幕行的移动"><a class="header" href="#实际行与屏幕行的移动">实际行与屏幕行的移动</a></h2>
<ul>
<li>jk在实际行之间移动。</li>
<li>0移动到实际行的行首。</li>
<li>^移动到实际行的第一个非空白字符。</li>
<li>gj和gk在屏幕行间移动。</li>
<li>g0移动到屏幕行的行首。</li>
<li>g$移动到屏幕行的行尾。</li>
<li>g^移动到屏幕行的第一个非空白字符。</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="技巧49-基于单词移动"><a class="header" href="#技巧49-基于单词移动">技巧49-基于单词移动</a></h1>
<ul>
<li>一组基于单词的动作命令</li>
</ul>
<pre><code>w 正向移动到下一单词的开头（forword)
b 反向移动到当前单词/上一单词的开头(back-word)
e 政协移动到当前单词/下一单词的结尾
ge 反向移动到上一单词的结尾
</code></pre>
<ul>
<li>ea命令连在一起可以解读为在当前单词结尾添加。</li>
<li>gea命令连在一起可以解读为在上一个单词结尾添加。</li>
</ul>
<h2 id="理解单词与字串"><a class="header" href="#理解单词与字串">理解单词与字串</a></h2>
<ul>
<li>单词word :h word查看帮助</li>
<li>字串WORD :h WORD查看帮助</li>
<li>下面一行有10个单词5个字串</li>
</ul>
<pre><code>e.g. we're going to slow
</code></pre>
<ul>
<li>上面的句子如果是基于单词的移动就很慢了。w命名显得很吃力。</li>
<li>如果是基于字串的移动，用更少的按键就可以达到同样的效果。</li>
<li>光标在行手WW将跳转到going的首字母。</li>
<li>光标在we的w上，想把we're改为it's的操作是</li>
</ul>
<pre><code>cWit's
</code></pre>
<ul>
<li>如果想更快地移动用基于字串的移动:W</li>
<li>如果想更细力度地移动用基于单词的移动:w</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="技巧50-对字符进行查找"><a class="header" href="#技巧50-对字符进行查找">技巧50-对字符进行查找</a></h1>
<ul>
<li>
<p>f{char} 命令是在Vim中移动的最快的方式之一。</p>
</li>
<li>
<p>如果找到了，就会把光标移动到此字符上。</p>
</li>
<li>
<p>如果未找到，则保持光标不动。</p>
</li>
<li>
<p>参考:h 。</p>
</li>
<li>
<p>; 重复之前的查找。</p>
</li>
<li>
<p>，退回上次查找。</p>
</li>
<li>
<p>F{char} 反向查找上一个{char}</p>
</li>
<li>
<p>t{char} 正向查找下一个{char}之前</p>
</li>
<li>
<p>T{char} 反向查找上一个{char}之后</p>
</li>
</ul>
<h2 id="想scrabble玩家那样思考"><a class="header" href="#想scrabble玩家那样思考">想Scrabble玩家那样思考</a></h2>
<ul>
<li>下面的例子，光标在一行开头I处，想要找到excellent并删除，怎么做更好？</li>
</ul>
<pre><code>Improve your writing by deleting excellent adjectives.
</code></pre>
<ul>
<li>方法1:</li>
</ul>
<pre><code>fe;;dw
</code></pre>
<ul>
<li>方法2:</li>
</ul>
<pre><code>fxdaw
</code></pre>
<ul>
<li>把x作为目标查找字符更佳。</li>
</ul>
<h2 id="总结-5"><a class="header" href="#总结-5">总结</a></h2>
<ul>
<li>在使用字符查找命令时，最好是选择出现频率比较低的字母作为目标字符。</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="技巧51-通过查找进行移动"><a class="header" href="#技巧51-通过查找进行移动">技巧51-通过查找进行移动</a></h1>
<ul>
<li>f{char}可以移动但是具有局限性。</li>
<li>一次查找一个字符。</li>
<li>只能在一行。</li>
<li>使用/查找tasks这个单词。</li>
<li>n命令重复上次查找，N命令反向查找。</li>
</ul>
<pre><code>/tasks&lt;CR&gt;
</code></pre>
<ul>
<li>启用hlsearch功能，以便高亮匹配项。</li>
</ul>
<p>查找动作操作文本</p>
<ul>
<li>在可视模式将选区扩大到到get</li>
</ul>
<pre><code>v/get&lt;CR&gt;
</code></pre>
<ul>
<li>删除到查找的文本get：d/get<CR></li>
</ul>
<pre><code>hello cfanzp.
get cfanzp and me.
d/get&lt;CR&gt;
删除后的文本:
hello get cfanzp and me.
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="技巧52-用精确的文本对象选择区域"><a class="header" href="#技巧52-用精确的文本对象选择区域">技巧52-用精确的文本对象选择区域</a></h1>
<ul>
<li>文本对象允许操作括号、被引用的文本、XML标签以及其它文本中常见结构。</li>
<li>光标在{}内，想高亮{}内的内容:</li>
</ul>
<pre><code>vi}
</code></pre>
<ul>
<li>选中由双引号括起来的字符范围:</li>
</ul>
<pre><code>va&quot;
</code></pre>
<ul>
<li>选中由双引号括起来的字符范围:</li>
</ul>
<pre><code>vi&quot;
</code></pre>
<ul>
<li>vi&quot;和va&quot;的区别是前者不包含分隔符后者包含。</li>
<li>类似操作还有：</li>
</ul>
<pre><code>a) ab
a} aB
a]
a&gt;
a'
a&quot;
a` 一对反引号
at 一对XML标签

i) ib
i} iB
i]
i&gt;
i'
i&quot;
i` 一对反引号
it 一对XML标签
</code></pre>
<h2 id="用文本对象执行操作"><a class="header" href="#用文本对象执行操作">用文本对象执行操作</a></h2>
<ul>
<li>只有操作符待决模式中使用文本对象，才能真正展现出他们的能力。</li>
<li>可以在可视模式以及操作符待决模式中使用文本对象。</li>
<li>每当在命令语法里看到{motion}时，也可以在这个地方使用文本对象。常见的例子:</li>
</ul>
<pre><code>d{motion}
c{motion}
y{motion}
</code></pre>
<ul>
<li>c{motion}：删除指定文本，然后切换到插入模式。</li>
<li>例如把abcd换成hello的操作为:ci&quot;hello<Esc></li>
</ul>
<pre><code>text:：
like &quot;abcd&quot;
opt:
ci&quot;hello&lt;Esc&gt;
</code></pre>
<h2 id="结论-1"><a class="header" href="#结论-1">结论</a></h2>
<ul>
<li>这些命令都只需要3次按键。都采用了技巧12中提到的简单语法规则。</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="技巧53-删除周边修改内部"><a class="header" href="#技巧53-删除周边修改内部">技巧53-删除周边，修改内部</a></h1>
<h2 id="文本对象分为2类"><a class="header" href="#文本对象分为2类">文本对象分为2类:</a></h2>
<ul>
<li>
<ol>
<li>操作分隔符的文本对象:i),i&quot;,it  称为:分隔符文本对象，Vim文档称：块对象</li>
</ol>
</li>
<li>
<ol start="2">
<li>操作文本块，入单词，句子和段落 称为:范围文本对象，Vim文档称：非块对象</li>
</ol>
</li>
<li>范围文本对象，i:可理解为inside,a可理解为around，iw:inside the word,aw:around the word</li>
</ul>
<pre><code>iw 当前单词
aw 当前单词及一个空格
iW 当前字串
aW 当前字串及一个空格
is 当前句子
as 当前句子及一个空格
ip 当前段落
ap 当前段落及一个空格
</code></pre>
<h2 id="总结-6"><a class="header" href="#总结-6">总结</a></h2>
<ul>
<li>daw,ciw,d{motion}与aw,as和ap配合，c{motion}与iw及类似文本对象一起用效果会更好。</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="技巧54-设置位置标记以便快速跳回"><a class="header" href="#技巧54-设置位置标记以便快速跳回">技巧54-设置位置标记，以便快速跳回</a></h1>
<ul>
<li>m{a-zA-z} 命令会用选定的字母标记当前光标所在位置。(参见:h m)
<ul>
<li>'{mark} 命令跳转到位置标记所在行，并把光标置于该行第一个非空白字符上。</li>
<li>`{mark} 命令跳转到位置标记所在处。</li>
<li>mm和`m:设置标记m和跳转到标记m。</li>
</ul>
</li>
</ul>
<h2 id="自动位置标记"><a class="header" href="#自动位置标记">自动位置标记</a></h2>
<pre><code>```
`` 当前文件中上次跳转动作之前的位置
`. 上次修改的地方
`^ 上次插入的地方
`[ 上次修改或复制的起始位置
`] 上次修改或复制的结束位置
`&lt; 上次高亮选区的起始位置
`&gt; 上次高亮选区的结束位置
```
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="技巧55-在匹配括号间跳转"><a class="header" href="#技巧55-在匹配括号间跳转">技巧55-在匹配括号间跳转</a></h1>
<ul>
<li>% 命令允许在一组开、闭括号间跳转(参见:h %),可作用于:(),{},[]。</li>
<li>matchit 插件增强%</li>
<li>vimrc开启matchit</li>
</ul>
<pre><code>set nocompatible
filetype plugin on
runtime macros/matchit.vim
</code></pre>
<h2 id="surroundvim插件"><a class="header" href="#surroundvim插件">surround.vim插件</a></h2>
<ul>
<li>S&quot; 命令用一对双引号报选中的文本括起来</li>
</ul>
<pre><code>S&quot;
s)
s}
</code></pre>
<ul>
<li>cs]} 命令把] 修改为}</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="技巧56-遍历跳转列表"><a class="header" href="#技巧56-遍历跳转列表">技巧56-遍历跳转列表</a></h1>
<h2 id="跳转列表"><a class="header" href="#跳转列表">跳转列表</a></h2>
<ul>
<li>动作命令在一个文件内移动，跳转则可以在文件间移动。</li>
<li>jumps查看</li>
</ul>
<pre><code>:jumps
</code></pre>
<ul>
<li>每次上下移动一行不算跳转。</li>
<li>任何改变当前窗口中活动文件的命令，都可以被陈伟跳转命令。</li>
<li>正在使用分割窗口或多标签页，那么<C-o>和<C-i>命令会始终在当前活动窗口的跳转列表范围内进行跳转。</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="技巧57-遍历改变列表"><a class="header" href="#技巧57-遍历改变列表">技巧57-遍历改变列表</a></h1>
<ul>
<li>查看改变列表</li>
</ul>
<pre><code>:changes
</code></pre>
<ul>
<li>changes列表中的change id 为0的为当前修改的位置。</li>
<li>正向遍历changes列表列表（changes列表向下）</li>
</ul>
<pre><code>g,
</code></pre>
<ul>
<li>反向遍历changes列表，从最近一次修改开始遍历。（changes列表向上）</li>
</ul>
<pre><code>g;
</code></pre>
<ul>
<li>跳到上次更改过的地方</li>
</ul>
<pre><code>g;
</code></pre>
<h2 id="标识上次修改方位的位置标记"><a class="header" href="#标识上次修改方位的位置标记">标识上次修改方位的位置标记</a></h2>
<ul>
<li><code>. 标记总是指向上次修改的位置 (:h </code>.)</li>
<li><code>^ 标记则会记录上次退出插入模式时光标所在的位置（:h </code>^)</li>
<li>gi 如果先退出插入模式，接着有在文档中四处移动，然后又想快速回到退出的地方继续编辑时，用gi命令就行了,此命令会用`^标记恢复光标位置，并切换到插入模式，这是省时省力的好办法。(:h gi)</li>
<li>Vim会为编辑会话中的每个单独缓冲区维护一个改变列表，而与之不同的是，每个窗口都会创建一个单独的跳转列表。</li>
</ul>
<h2 id="总结-7"><a class="header" href="#总结-7">总结</a></h2>
<ul>
<li>下面这些技巧有必要记住，省时省力</li>
<li>g; 跳转到上一个修改过的地方</li>
<li>g,跳转到下一个修改过的地方</li>
<li>`^ 标记上次插入的位置</li>
<li>gi:跳转到上次插入的位置，并且进入插入模式</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="技巧58-跳转到光标下的文件"><a class="header" href="#技巧58-跳转到光标下的文件">技巧58-跳转到光标下的文件</a></h1>
<ul>
<li>Vim会吧文档中的文件名当成一个超连接。正确配置后，就可以用gf命令跳转到光标下的文件了。</li>
<li>gf 可以想成 go to file (:h gf)</li>
</ul>
<h2 id="指定文件扩展名"><a class="header" href="#指定文件扩展名">指定文件扩展名</a></h2>
<ul>
<li>添加.lua扩展名支持</li>
</ul>
<pre><code>:set suffixesadd+=.lua
</code></pre>
<h2 id="指定要搜寻的目录"><a class="header" href="#指定要搜寻的目录">指定要搜寻的目录</a></h2>
<ul>
<li>查看path的值</li>
</ul>
<pre><code>set path?
</code></pre>
<ul>
<li>目录含义</li>
</ul>
<pre><code>. 代表当前文件所在目录
,, 空字符串(由2个连着的逗号界定):代表工作目录
</code></pre>
<ul>
<li>与gf类似命令Ctrl+]</li>
<li>Ctrl+] 是基于ctags在文件间跳转,需要确保tags文件是最新的。</li>
<li>具体介绍ctags和Ctrl+] 可以看技巧103,和技巧104。</li>
</ul>
<h2 id="总结-8"><a class="header" href="#总结-8">总结</a></h2>
<ul>
<li>使用gf在当前窗口跳转，或CTRL-M CTRL-F分屏打开</li>
<li>使用CTRL-o跳转回来，CTRL-^来回跳转，CTRL-i往后跳。</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="技巧59-用全局位置标记在文件间快速"><a class="header" href="#技巧59-用全局位置标记在文件间快速">技巧59-用全局位置标记在文件间快速</a></h1>
<ul>
<li>全局位置标记是一种书签，让我们可以在文件间跳转。</li>
<li>m{letter} 在当前光标位置创建一个位置标记(:h m查看帮助)。</li>
<li><code>{letter}命令使光标快速回到标记所在之处（:h </code>查看帮助）。</li>
<li>默认情况下，全局标记在2次编辑会话之间仍然会保留(这个是可以配置的:h 'viminfo'查看)。</li>
</ul>
<h2 id="在浏览代码前先设置一个全局标记"><a class="header" href="#在浏览代码前先设置一个全局标记">在浏览代码前先设置一个全局标记</a></h2>
<ul>
<li>
<p>当需要浏览一些文件，然后再快速跳回到原处时，全局标记会显得特别有用。</p>
</li>
<li>
<p>eg:</p>
</li>
<li>
<p>我们正在编码，想找到代码中所有出现DLOG函数的地方,用:vimgrep（安装了ag插件可以用Ag）。</p>
</li>
<li>
<p>默认情况下,:vimgrep会直接跳到它所找到的第一处匹配上，可能会切换到另外一个文件。可以用Ctrol-o命令回到执行:vimgrep之前的位置。</p>
</li>
<li>
<p>假如已经遍历了几个查找项，想回到之前的位置，怎么做呢？多按几次Ctrl-o反向遍历。但是会比较麻烦。</p>
</li>
<li>
<p>更好的选择是:在调用vimgrep之前，先执行mM,在想回来的时候执行`M。</p>
</li>
<li>
<p>标记当前位置为M</p>
</li>
</ul>
<pre><code>mM
</code></pre>
<ul>
<li>跳转到标记M</li>
</ul>
<pre><code>`M
</code></pre>
<h2 id="需要养成习惯"><a class="header" href="#需要养成习惯">需要养成习惯:</a></h2>
<ul>
<li>在使用与quickfix列表有关的命令前，如:grep、vimgrep、make、Ag等，先设置全局标记。</li>
<li>在执行与缓冲区列表或参数列表有关的命令前，如:args {arglist},argdo,也要设置全局标记。</li>
<li>总共可以设置26个全局位置标记，足够用了，可以毫无顾及地用。</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="技巧60-用无名寄存器实现删除复制与粘贴操作"><a class="header" href="#技巧60-用无名寄存器实现删除复制与粘贴操作">技巧60-用无名寄存器实现删除、复制与粘贴操作</a></h1>
<h3 id="1-调换字符"><a class="header" href="#1-调换字符">1. 调换字符</a></h3>
<ul>
<li>将“Practica lvim”改为“Practical vim”,操作如下，其中xp：吧空格字符剪切下来，放入无名寄存器，最后p将无名寄存器的内容贴到光标后面。</li>
</ul>
<pre><code>f空格
xp
</code></pre>
<ul>
<li>xp: 调换光标之后的两个字符。 </li>
</ul>
<h3 id="2-调换文本行"><a class="header" href="#2-调换文本行">2. 调换文本行</a></h3>
<ul>
<li>ddp:调换当前行和它的下一行。</li>
</ul>
<h3 id="3--创建文本行的副本"><a class="header" href="#3--创建文本行的副本">3 . 创建文本行的副本</a></h3>
<ul>
<li>yyp:复制当前行粘贴到下一行。</li>
</ul>
<h3 id="4-diw-会删除当前单词放入无名寄存器中"><a class="header" href="#4-diw-会删除当前单词放入无名寄存器中">4. diw 会删除当前单词，放入无名寄存器中</a></h3>
<div style="break-before: page; page-break-before: always;"></div><h1 id="技巧61-深入理解vim寄存器"><a class="header" href="#技巧61-深入理解vim寄存器">技巧61-深入理解Vim寄存器</a></h1>
<ul>
<li>引用一个寄存器</li>
<li>Vim的删除、复制与粘贴命令都会用到众多寄存器中的某一个。</li>
<li>可以同时给命令加&quot;{register}前缀的方式指定要用的寄存器。若不指明，Vim将缺省使用无名寄存器。</li>
<li>Vim 剪切复制与粘贴对应的术语:delete，yank与put。</li>
</ul>
<h2 id="一些寄存器的例子"><a class="header" href="#一些寄存器的例子">一些寄存器的例子</a></h2>
<ul>
<li>把当前单词复制到a寄存器中</li>
</ul>
<pre><code>&quot;ayiw
</code></pre>
<ul>
<li>把当前整行文本剪切至寄存器b中。</li>
</ul>
<pre><code>&quot;bdd
</code></pre>
<ul>
<li>把b寄存器的内容粘贴出来</li>
</ul>
<pre><code>&quot;bp
</code></pre>
<h2 id="无名寄存器"><a class="header" href="#无名寄存器">无名寄存器(&quot;&quot;)</a></h2>
<ul>
<li>
<p>倘若没有指定要使用的寄存器，Vim将缺省使用无名寄存器。</p>
</li>
<li>
<p>无名寄存器用双引号表示（:h quote_quote）。</p>
</li>
<li>
<p>&quot;&quot;p等同于p</p>
</li>
<li>
<p>x、s、d{mition}、c{motion}、与y{motion}命令(以及它们对应的大些命令)都会覆盖无名寄存器中的内容。</p>
</li>
<li>
<p>x和d{motion}应该被理解为剪切命令更合适，它们会覆盖无名寄存器的内容。</p>
</li>
</ul>
<h2 id="复制专用寄存器0"><a class="header" href="#复制专用寄存器0">复制专用寄存器(&quot;0)</a></h2>
<ul>
<li>当使用y{motion}寄存器时，要复制的文本不仅会被拷贝到无名寄存器中，而且也被拷贝到了复制专用寄存器中，后者可以用数字0加以引用。(:h quote0)</li>
<li>复制专用寄存器，仅当使用y{motion}命令时才会被赋值。</li>
<li>使用 &quot;0P 复制出复制专用寄存器中的内容。</li>
</ul>
<h2 id="查看寄存器的内容"><a class="header" href="#查看寄存器的内容">查看寄存器的内容</a></h2>
<ul>
<li>查看所有寄存器的内容</li>
</ul>
<pre><code>:reg
</code></pre>
<ul>
<li>查看复制专用寄存器的内容</li>
</ul>
<pre><code>:reg &quot;0
</code></pre>
<h2 id="有名寄存器a-z"><a class="header" href="#有名寄存器a-z">有名寄存器(&quot;a-&quot;z)</a></h2>
<ul>
<li>查看a寄存器内容</li>
</ul>
<pre><code>reg a
</code></pre>
<h2 id="黑洞寄存器"><a class="header" href="#黑洞寄存器">黑洞寄存器</a></h2>
<ul>
<li>黑洞寄存器可以用下划线引动它。</li>
<li>如果只想删除文本却不想覆盖无名寄存器中的内容时，此命令很官用。</li>
</ul>
<h2 id="系统剪贴板-与选择专用寄存器"><a class="header" href="#系统剪贴板-与选择专用寄存器">系统剪贴板(&quot;+) 与选择专用寄存器(&quot;*)</a></h2>
<ul>
<li>Vim的加号寄存器与系统剪贴板等效，可用+号引用。</li>
<li>&quot;+p命令将其粘贴到Vim内部。</li>
<li>插入模式下用Ctrl-r+将其粘贴到Vim内部。</li>
<li>如果在Vim的复制或删除命令之前加入&quot;+，相应的文本将被捕获至系统剪切板。</li>
<li>X11视窗系统支持另一种被叫做主剪切板(primary)的剪贴板，它保存着上次被高亮选中的文本，可以用鼠标中键把他们粘贴出来。</li>
<li>Vim的星好寄存器对应主剪贴板，可以用*号加以引用。</li>
<li>&quot;+ X11剪贴板，用剪切、复制与粘贴命令操作。</li>
<li>&quot;* X11主剪贴板，用鼠标中键操作。</li>
<li>X11剪贴板的功能可在编译Vim时被激活或禁用。</li>
<li>运行:version命令，然后找到xterm_clipboard关键字，如果前面有个减号，就表示不支持。</li>
</ul>
<h2 id="其它寄存器"><a class="header" href="#其它寄存器">其它寄存器</a></h2>
<ul>
<li>可以显式地使用删除与复制命令来设置有名、无名以及复制专用寄存器的内容。</li>
<li>只读寄存器:Vim还提供了几组可被隐式赋值的寄存器。</li>
</ul>
<pre><code>&quot;% 当前文件名
&quot;# 轮换文件名
&quot;. 上次插入的文本
&quot;: 上次执行的Ex命令
&quot;/ 上次查找的模式
</code></pre>
<ul>
<li>以技术上讲，&quot;/寄存器并非只读，可以用:let命令对其进行显式赋值。</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="技巧62-用寄存器中的内容替换高亮选区的内容"><a class="header" href="#技巧62-用寄存器中的内容替换高亮选区的内容">技巧62-用寄存器中的内容替换高亮选区的内容</a></h1>
<ul>
<li>在可视模式下使用p命令时，Vim将用指定的寄存器内容来替换高亮选区中的文本。</li>
<li>可以解决弄丢了复制内容的问题</li>
<li>把删除和粘贴合成了一步，不需要先删除高亮选区的内容再粘贴。</li>
<li>无名寄存器的内容和高亮选区的内容通过p命令交换了。</li>
</ul>
<h2 id="交换2个词"><a class="header" href="#交换2个词">交换2个词</a></h2>
<ul>
<li>eg:光标在I处将chips and fish 换成:fish and chips</li>
<li>m{char}负责设置标记，<code>{char}</code>负责跳转到该标记。更多信息可以参考<a href="https://blog.csdn.net/cfanzp/article/details/122935485?spm=1001.2014.3001.5502">技巧54</a></li>
</ul>
<pre><code>{start} I like chips and fish
fc: 光标跳到chips的c处
de: 剪切chips
mm: 当前位置标记为m
ww(或ff):光标跳到fish的f处
ve:选中可视模式选中fish
p:交换选中的词与无名寄存器中的chips,选中部分变成chips,无名寄存器中变成fish
`m:跳到标记m处
p:粘贴无名寄存器的内容fish
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="技巧63-把寄存器的内容粘贴出来"><a class="header" href="#技巧63-把寄存器的内容粘贴出来">技巧63-把寄存器的内容粘贴出来</a></h1>
<ul>
<li>p命令将寄存器中的文本粘贴到光标之后。</li>
<li>P命令奖寄存器中的文本粘贴到光标之前。</li>
</ul>
<h2 id="粘贴面向字符的区域"><a class="header" href="#粘贴面向字符的区域">粘贴面向字符的区域</a></h2>
<ul>
<li>在普通模式用p或P。</li>
<li>在插入模式用Ctrl-r{register}</li>
<li>这种方式，寄存器中的文本总会被插入光标之前，就像我们在插入模式下手动输入一样。</li>
<li>Ctrl-r0 插入复制专用寄存器的内容</li>
<li>Ctrl-r&quot; 插入无名寄存器的内容</li>
</ul>
<h2 id="粘贴面向行的区域"><a class="header" href="#粘贴面向行的区域">粘贴面向行的区域</a></h2>
<ul>
<li>当要粘贴的内容来自于面向行的寄存器时，p和P命令会把他们粘贴至当前行的上衣行或下一行。</li>
<li>gp,和gP作用同p,P，区别:将光标移动到粘贴出来的文本结尾而不是开头。</li>
<li>当复制多行文本时，gP命令尤其管用。</li>
</ul>
<h2 id="结论-2"><a class="header" href="#结论-2">结论</a></h2>
<ul>
<li>p与P命令对于粘贴多行文本区域非常重要。</li>
<li>对于小段的面向字符的文本来讲，使用Ctrl-r{register}映射项的方式会更直观。</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="技巧64-与系统剪贴板进行交换"><a class="header" href="#技巧64-与系统剪贴板进行交换">技巧64-与系统剪贴板进行交换</a></h1>
<h2 id="了解你所用系统的剪贴命令"><a class="header" href="#了解你所用系统的剪贴命令">了解你所用系统的剪贴命令</a></h2>
<ul>
<li>在OS X中，Cmd-v映射会触发系统粘贴命令。</li>
<li>在Windows,Linux中比较复杂。</li>
<li>Ctrl-v是系统粘贴命令的标准映射项。</li>
<li>普通模式下Ctrl-v会激活Visual-Block模式。</li>
<li>在插入模式下，它允许插入字符本身或字符编码。</li>
</ul>
<h2 id="在插入模式下使用系统粘贴命令"><a class="header" href="#在插入模式下使用系统粘贴命令">在插入模式下使用系统粘贴命令。</a></h2>
<ul>
<li>'autoindent'选项被启用，当创建新行时，Vim都会保持同级缩进。这样剪贴板复制过来会导致一行比一行往右偏。</li>
<li>paste选项允许手动通知Vim要使用系统粘贴命令了。</li>
<li>paste选项启用后，Vim将禁用所有插入模式下的映射项和缩写，并重置很多选项，其中就包括autoindent。</li>
<li>关闭paste:</li>
</ul>
<pre><code>:set paste!
</code></pre>
<ul>
<li>paste选项启用后，在Vim插入模式下创建自定义映射项的方法都失效了。作为替代方案，可以把pastetoggle选项映射成一个功能键。</li>
</ul>
<pre><code>:set pastetoggle=&lt;f5&gt;
</code></pre>
<ul>
<li>请试着在命令行窗口执行以上命令，用f5来切换paste,在插入模式和普通模式下都能用。</li>
<li>可以把上面的配置命令拷贝到自己的vimrc文件。</li>
</ul>
<h2 id="为避免切换paste选项请使用加号寄存器进行粘贴"><a class="header" href="#为避免切换paste选项请使用加号寄存器进行粘贴">为避免切换&quot;paste&quot;选项，请使用加号寄存器进行粘贴。</a></h2>
<ul>
<li>如果Vim是已集成系统剪贴板的版本，就可以完全避免与paste选项打交道了。</li>
<li>Vim集成了系统剪贴板的情况下，普通模式下的&quot;+p命令用来粘贴加号寄存器中的内容，即系统剪贴板的镜像。</li>
<li>更多细节，请参见系统剪贴板(&quot;+)与选择专用寄存器(&quot;*).</li>
<li>Vim集成了系统剪贴板的情况下，无论paste与autoindent选项激活与否，该命令都能保证位于剪贴板中的文本缩进不会乱套。</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="技巧65-宏的读取与执行"><a class="header" href="#技巧65-宏的读取与执行">技巧65-宏的读取与执行</a></h1>
<h2 id="把命令序列录制成宏"><a class="header" href="#把命令序列录制成宏">把命令序列录制成宏</a></h2>
<ul>
<li>qa 开始录制宏并将其内容保存至寄存器a中。</li>
<li>按q 停止录制。</li>
<li>:reg a 查看 a寄存器中的内容。</li>
</ul>
<h2 id="通过执行宏来回放命令序列"><a class="header" href="#通过执行宏来回放命令序列">通过执行宏来回放命令序列</a></h2>
<ul>
<li>可以用@{register}命令执行指定寄存器的内容。</li>
<li>用@@来重复最近调用过的宏。</li>
</ul>
<h2 id="以串行方式执行宏"><a class="header" href="#以串行方式执行宏">以串行方式执行宏</a></h2>
<ul>
<li>相互影响 例子：技巧68</li>
</ul>
<h2 id="以并行方式执行宏"><a class="header" href="#以并行方式执行宏">以并行方式执行宏</a></h2>
<ul>
<li>互不影响 例子：技巧70</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="技巧66-规范光标位置直达目标以及中止宏"><a class="header" href="#技巧66-规范光标位置直达目标以及中止宏">技巧66-规范光标位置、直达目标以及中止宏</a></h1>
<ul>
<li>黄金法则:在录制一个宏时，要确保每条命令都可被重复执行。</li>
</ul>
<h2 id="规范光标位置"><a class="header" href="#规范光标位置">规范光标位置</a></h2>
<ul>
<li>应该把光标移动到下一处查找匹配项(n),或是当前行的行首(0),又或是当前文件的行首(gg).</li>
<li>如果每次总是从确定的位置开始执行的话，那么命中正确的目标会变得更容易。</li>
</ul>
<h2 id="用可重复的动作命令直达目标"><a class="header" href="#用可重复的动作命令直达目标">用可重复的动作命令直达目标</a></h2>
<ul>
<li>面向单词的动作命令，如:w,b,e和ge</li>
<li>推荐用查找命令定位定位，或用文本对象。</li>
<li>尽量使你的宏兼具灵活性与重复性。</li>
<li>录制宏的过程中禁止用鼠标。</li>
</ul>
<h2 id="当动作命令失败时宏将中止执行"><a class="header" href="#当动作命令失败时宏将中止执行">当动作命令失败时，宏将中止执行。</a></h2>
<ul>
<li>Vim的动作命令可能会执行失败。Vim缺省会发出哔地一声。可以设置visualbell关闭提示音。</li>
<li>如果宏执行动作命令失败了，Vim将中止执行宏的其余命令。</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="技巧67-加次数回放宏"><a class="header" href="#技巧67-加次数回放宏">技巧67-加次数回放宏</a></h1>
<ul>
<li>不用精确计算宏的次数，估算一个足够大的次数。
作者通常是用22这个数字，2与@字啊用一个键上，容易输入。</li>
<li>在下面行每个+号左右加上空格</li>
<li>录制宏qqf+s + jkq</li>
<li>qq:录制宏保存在q寄存器里</li>
<li>f+:查找+号</li>
<li>s:删除+号并进入插入模式</li>
<li>
<ul>
<li>:输入&quot;空格+空格&quot;</li>
</ul>
</li>
<li>jk::退出插入模式(也可以用&lt;Esc&gt;)</li>
<li>q:退出宏录制</li>
<li>22@q</li>
</ul>
<pre><code>x=&quot;(&quot;+a+&quot;,&quot;+&quot;,&quot;+b+&quot;,&quot;+c+&quot;,&quot;+d+&quot;,&quot;+e+&quot;)&quot;;
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="技巧68-在连续的文本行上重复修改"><a class="header" href="#技巧68-在连续的文本行上重复修改">技巧68-在连续的文本行上重复修改</a></h1>
<ul>
<li>对于多行范围内的重复性改动，可以先录制一个宏。然后再在没一行上回放，这将会极大减轻我们的工作量。</li>
<li>该功能可用串行或并行两种执行宏的方式实现。</li>
</ul>
<h2 id="demo1"><a class="header" href="#demo1">demo1</a></h2>
<ul>
<li>目标文本</li>
</ul>
<pre><code>1. one
2. two
3. three
4. four
</code></pre>
<ul>
<li>转换后的文本</li>
</ul>
<pre><code>1) One
2) Two
3) Three
4) Four
</code></pre>
<h3 id="录制工作单元"><a class="header" href="#录制工作单元">录制工作单元。</a></h3>
<ul>
<li>先在第一行上做出修改，并将其录制下来。</li>
</ul>
<pre><code>qa 开始录制宏保存到a寄存器
0f. 将光标先放在行首，查找.符号
r) 将.替换成)
w~ w移动大下一个单词的首字母 ~大小写反转
j 跳转到下一行
q 结束宏录制
3@a 调用宏3次。
</code></pre>
<ul>
<li>并行方式1:使用可视模式选择选区。</li>
</ul>
<pre><code>VG: normal @a
</code></pre>
<ul>
<li>并行方式2:使用行号指定范围执行宏命令。</li>
</ul>
<pre><code>:2,4 normal @a
</code></pre>
<h2 id="demo2"><a class="header" href="#demo2">demo2</a></h2>
<ul>
<li>目标文本</li>
</ul>
<pre><code>1. one
2. two
//test
3. three
4. four
</code></pre>
<ul>
<li>转换后的文本</li>
</ul>
<pre><code>1) One
2) Two
//test
3) Three
4) Four
</code></pre>
<ul>
<li>demo2如果使用demo1中的串行方式允许到test相应行就会出错，这个时候需要用并行方式。</li>
</ul>
<h2 id="决策串行还是并行"><a class="header" href="#决策串行还是并行">决策:串行还是并行？</a></h2>
<ul>
<li>串行或者并行，哪种方式更好呢？答案是看情况。</li>
<li>以并行的方式在多处执行更为健壮。</li>
<li>如果在执行时遇到一处错误，而我们正想利用这些警告更正错误时，以串行、多次的方式执行宏可以更容易定位出问题所在。</li>
<li>在掌握这2种技术后，可以自己判断在哪种情况下应该使用哪种方式了。</li>
</ul>
<h2 id="总结-9"><a class="header" href="#总结-9">总结</a></h2>
<ul>
<li>基础知识点回顾</li>
<li>qa 录制宏保存在a寄存器</li>
<li>q结束录制宏</li>
<li>3@a 3次调用寄存器a里面的宏</li>
<li>0跳到行首</li>
<li>f. 查找字符.</li>
<li>r) 替换当前字符为)</li>
<li>w 向前移动一个字符</li>
<li>~ 字符大小写反转</li>
<li>j 向下移动一行</li>
<li>:2,4 normal @a 底行模式在2到4行执行命令寄存器a中保存的宏</li>
<li>VG 进入可视模式选择行从当前行到最后一行</li>
<li>使用串行还是并行，具体看情况而定。</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="技巧69-给宏追加命令"><a class="header" href="#技巧69-给宏追加命令">技巧69-给宏追加命令</a></h1>
<ul>
<li>在录制宏的过程中可能会漏掉某个步骤。在这种情况下，没必要重头开始录制，可以在现有宏的结尾附加额外的命令。</li>
<li>如果是在结尾缺少命令可以附加，如果是在中间或前面就不能了。</li>
<li>追加到a寄存器的方法:例如需要追加j</li>
</ul>
<pre><code>qA
j
q
</code></pre>
<ul>
<li>追加到q寄存器的方法:例如需要追加j</li>
</ul>
<pre><code>qQ
j
q
</code></pre>
<h2 id="结论-3"><a class="header" href="#结论-3">结论</a></h2>
<ul>
<li>这条技巧可以让我们在没录制完就不小心按了q结束了的情况下可以继续录制。</li>
<li>如果是在宏的开头或者中间的某个位置添加内容，技巧72中，将学习一种更好的方法，用于修改改已录制好的宏。</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="技巧70-在一组文件中执行宏"><a class="header" href="#技巧70-在一组文件中执行宏">技巧70-在一组文件中执行宏</a></h1>
<h2 id="建立目标文件列表"><a class="header" href="#建立目标文件列表">建立目标文件列表</a></h2>
<pre><code>：args *.lua
</code></pre>
<ul>
<li>显示参数列表中的内容</li>
</ul>
<pre><code>:args
</code></pre>
<h2 id="录制宏"><a class="header" href="#录制宏">录制宏</a></h2>
<ul>
<li>在开始录制前，首先要确保光标已经位于参数列表中的第一个文件中</li>
</ul>
<pre><code>:first
</code></pre>
<ul>
<li>正常录制宏</li>
</ul>
<h2 id="以并行方式执行此宏"><a class="header" href="#以并行方式执行此宏">以并行方式执行此宏</a></h2>
<ul>
<li>先丢弃录制宏时的修改，防止批量执行时对第一个缓冲区执行了2次。</li>
</ul>
<pre><code>:edit!
</code></pre>
<ul>
<li>执行宏</li>
</ul>
<pre><code>:argdo normal @a
</code></pre>
<h2 id="以串行方式执行宏-1"><a class="header" href="#以串行方式执行宏-1">以串行方式执行宏</a></h2>
<pre><code>qA 追加宏录制
:next 打开下一个缓冲区文件
q 结束宏录制
22@q 批量运行宏
</code></pre>
<h3 id="保存所有文件的改动"><a class="header" href="#保存所有文件的改动">保存所有文件的改动</a></h3>
<ul>
<li>方法1</li>
</ul>
<pre><code>:argdo write
</code></pre>
<ul>
<li>方法2</li>
</ul>
<pre><code>:wall
</code></pre>
<ul>
<li>方法3</li>
</ul>
<pre><code>qA
:wnext
q
</code></pre>
<h2 id="结论-4"><a class="header" href="#结论-4">结论</a></h2>
<ul>
<li>多个缓冲区执行宏的时候，串行的方式比并行的更好一些，出错了，更容易发现。</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="技巧71-用迭代求值的方式给列表编号"><a class="header" href="#技巧71-用迭代求值的方式给列表编号">技巧71-用迭代求值的方式给列表编号</a></h1>
<h2 id="在每行加入连续的数字"><a class="header" href="#在每行加入连续的数字">在每行加入连续的数字</a></h2>
<ul>
<li>修改前文本</li>
</ul>
<pre><code>aaa
bbb
ccc
ddd
eee
</code></pre>
<ul>
<li>修改后文本</li>
</ul>
<pre><code>1) aaa
2) bbb
3) ccc
4) ddd
5) eee
</code></pre>
<h2 id="方法1利用快捷键"><a class="header" href="#方法1利用快捷键">方法1,利用快捷键</a></h2>
<pre><code>Ctrl-a:数字+1
Ctrl-x:数字-1
</code></pre>
<h2 id="方法2利用寄存器基于vim的脚本"><a class="header" href="#方法2利用寄存器基于vim的脚本">方法2,利用寄存器,基于Vim的脚本</a></h2>
<pre><code>:let i=0
:let i += 1
:echo i
</code></pre>
<ul>
<li>插入变量i的值:</li>
</ul>
<pre><code>&lt;Ctrl-r&gt;=i&lt;CR&gt;
</code></pre>
<ul>
<li>录制宏</li>
</ul>
<pre><code>:let i=1
qa
I&lt;Ctrl-r&gt;=i&lt;CR&gt;)&lt;Esc&gt;
:let i+= 1
q
</code></pre>
<ul>
<li>执行宏</li>
</ul>
<pre><code>jVG
:`&lt;,`&gt;normal @a
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="技巧72-编辑宏的内容"><a class="header" href="#技巧72-编辑宏的内容">技巧72-编辑宏的内容</a></h1>
<h2 id="将宏粘贴到文档中"><a class="header" href="#将宏粘贴到文档中">将宏粘贴到文档中</a></h2>
<ul>
<li>put</li>
</ul>
<pre><code>G 跳到最后一行
:put a 将寄存器a中的内容粘贴到当前行的下方
</code></pre>
<h2 id="编辑宏"><a class="header" href="#编辑宏">编辑宏</a></h2>
<ul>
<li>宏复制到文档中后，可以像编辑正常文本一样编辑宏了。</li>
</ul>
<h2 id="将宏从文档复制回寄存器"><a class="header" href="#将宏从文档复制回寄存器">将宏从文档复制回寄存器</a></h2>
<ul>
<li>方法1</li>
<li>副作用:寄存器会包含一个拖尾字符^J,表示一个换行符，大多数情况无关紧要，但有时会改变宏的意义。</li>
</ul>
<pre><code>&quot;add 或者:d a
</code></pre>
<ul>
<li>方法2,用面向字符的复制操作</li>
</ul>
<pre><code>0  光标移动到行首
”ay$ 复制文本当前字符到行尾部，保存到a寄存器
dd 使用dd删除这一行
</code></pre>
<h2 id="结论-5"><a class="header" href="#结论-5">结论</a></h2>
<ul>
<li>使用寄存器得特别谨慎（出于宏中的键盘编码罗列的诸多原因）。</li>
<li>如果只需要将1条命令附加于宏的结尾，使用技巧69更简单。</li>
<li>也可以编写Vim脚本来操作寄存器。例如:能用substitute()函数。</li>
</ul>
<pre><code>：let @a=substitute(@a,''\~'','vU','g')
：h function-list 查看更多帮助
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="技巧73-调整查找模式的大小写敏感性-学习笔记"><a class="header" href="#技巧73-调整查找模式的大小写敏感性-学习笔记">技巧73-调整查找模式的大小写敏感性 学习笔记</a></h1>
<h3 id="全局设置大小写敏感性"><a class="header" href="#全局设置大小写敏感性">全局设置大小写敏感性</a></h3>
<ul>
<li>:set ignorecase  Vim的查找模式将不区分大小写。</li>
</ul>
<h3 id="每次查找时设置大小写敏感性"><a class="header" href="#每次查找时设置大小写敏感性">每次查找时设置大小写敏感性</a></h3>
<ul>
<li>\c 忽略大小写。</li>
<li>\C 强制区分大小写。</li>
</ul>
<h3 id="启用更加智能的大小写明个性设置"><a class="header" href="#启用更加智能的大小写明个性设置">启用更加智能的大小写明个性设置</a></h3>
<ul>
<li>smartcase</li>
<li>调整查找模式的大小写敏感性</li>
</ul>
<div class="table-wrapper"><table><thead><tr><th style="text-align: left">模式</th><th style="text-align: left">ignorecase</th><th style="text-align: left">smartcase</th><th style="text-align: left">匹配</th></tr></thead><tbody>
<tr><td style="text-align: left">foo</td><td style="text-align: left">off</td><td style="text-align: left">-</td><td style="text-align: left">foo</td></tr>
<tr><td style="text-align: left">foo</td><td style="text-align: left">on</td><td style="text-align: left">-</td><td style="text-align: left">foo Foo FOO</td></tr>
<tr><td style="text-align: left">foo</td><td style="text-align: left">on</td><td style="text-align: left">on</td><td style="text-align: left">foo Foo FOO</td></tr>
<tr><td style="text-align: left">Foo</td><td style="text-align: left">on</td><td style="text-align: left">on</td><td style="text-align: left">Foo</td></tr>
<tr><td style="text-align: left">Foo</td><td style="text-align: left">on</td><td style="text-align: left">off</td><td style="text-align: left">foo Foo FOO</td></tr>
<tr><td style="text-align: left">\cfoo</td><td style="text-align: left">-</td><td style="text-align: left">-</td><td style="text-align: left">foo Foo FOO</td></tr>
<tr><td style="text-align: left">foo\C</td><td style="text-align: left">-</td><td style="text-align: left">-</td><td style="text-align: left">foo</td></tr>
</tbody></table>
</div><div style="break-before: page; page-break-before: always;"></div><h1 id="技巧74-按正则表达式查找时使用v模式开关-学习笔记"><a class="header" href="#技巧74-按正则表达式查找时使用v模式开关-学习笔记">技巧74-按正则表达式查找时，使用\v模式开关 学习笔记</a></h1>
<ul>
<li>Vim正则表达式的语法风格更接近POSIX.</li>
<li>使用very magic模式开关，就可以让Vim采用我们更为熟悉的正则表达式语法了。</li>
</ul>
<h2 id="用magic搜索模式查找十六进制颜色代码"><a class="header" href="#用magic搜索模式查找十六进制颜色代码">用magic搜索模式查找十六进制颜色代码</a></h2>
<ul>
<li>文本</li>
</ul>
<pre><code>body {color:#3c3c3c;}
a {color:#0000EE;}
strong {color:#000;}
</code></pre>
<ul>
<li>查找</li>
</ul>
<pre><code>/#\([0-9a-fA-f]\{6}|[0-9a-fA-F]\{3}\)
    ```

## 用very magic 搜索模式查找十六进制颜色代码
- 可以用\v模式开关来统一所有特殊符号的规则。
- very magic模式:除_、大小写字母以及数字0～9之外的所有字符都具有特殊含义。
- :h \v 查看帮助
- \v模式开关使得Vim的正则表达式引擎表现的更像是Perl,Python或者Ruby所为。但是有差异。
- 与规定的哪个必须转义或者不得转义相比，\v模式开关的规则更容易记忆。
- 加了\v开关特殊字符都不需要加反斜杠了，可读性更强了。
</code></pre>
<p>/\v#([0-9a-fA-F]{6}|[0-9a-fA-F]{3})</p>
<pre><code>
## 用十六进制字符类进一步优化模式
</code></pre>
<p>\x:代表[0=9a-fA-F]
/\v#(\x{6}|\x{3})</p>
<pre><code>
- 字符#没有特殊含义，因此可按原义匹配。
- Vim的解释是任何还未具备特殊含义的字符都被&quot;保留以备将来扩展时使用&quot;(参见:h/\\)
- 尽管#目前不具有特殊含义，但是以后可能会有。
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="技巧75-按原义查找文本时使用v原义开关-学习笔记"><a class="header" href="#技巧75-按原义查找文本时使用v原义开关-学习笔记">技巧75-按原义查找文本时，使用\V原义开关 学习笔记</a></h1>
<h1 id="按原义查找文本时使用v原义开关"><a class="header" href="#按原义查找文本时使用v原义开关">按原义查找文本时，使用\V原义开关</a></h1>
<ul>
<li>使用\V会使得其后的模式中只有反斜杠有特殊的意义。</li>
<li>例如想查找a.k.a</li>
</ul>
<pre><code>/a.k.a  会匹配很多结果，因为.代表任意字符
/a\./k\.a 能正确匹配结果，但是需要对每个.进行转义
/\Va.k.a 只会匹配a.k.a
</code></pre>
<ul>
<li>如果想用正则表达式查找，就用模式开关\v（小写的v)</li>
<li>如果想按原义查找文本，就用原义开关\V(大写的V)</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="技巧76-使用圆括号捕获子匹配-学习笔记"><a class="header" href="#技巧76-使用圆括号捕获子匹配-学习笔记">技巧76-使用圆括号捕获子匹配 学习笔记</a></h1>
<ul>
<li>当指定一个模式时，可以捕获其子匹配并在其他地方引用它们。</li>
<li>此功能与substitute命令组合起来尤为好用，但它可用于定义某一类模式，这类模式的特点是重复包含某个单词。</li>
<li>例子</li>
</ul>
<pre><code>I love Paris in the
the springtime.
</code></pre>
<ul>
<li>一个专门用来匹配重复单词的正则表达式</li>
</ul>
<pre><code>/\v&lt;(\w+)\_s+\1&gt;
</code></pre>
<ul>
<li>(): 任何圆括号内部的匹配文本都会自动保存到一个临时的仓库。</li>
<li>\1 : 可以用\1引用这段被捕获的文本。</li>
<li>如果模式中包含不止一组圆括号，则可以用\1、\2,直到\9，引用被每对()捕获的子匹配。</li>
<li>不论模式中是否使用了圆括号，元字符\0永远会引用整个匹配。</li>
<li>&lt;和&gt;两符号将用于匹配单词边界</li>
<li>元字符_s会匹配空白符或换行符</li>
<li>在查找模式中使用子匹配的场景并不太多。</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="技巧77-界定单词的边界-学习笔记"><a class="header" href="#技巧77-界定单词的边界-学习笔记">技巧77-界定单词的边界 学习笔记</a></h1>
<ul>
<li>在very magic搜索模式下，用&lt;与&gt;符号表示单词定界符。</li>
<li>\w匹配单词类字符:包括字母、数字以及符号&quot;_&quot;。</li>
<li>\W匹配除单词类字符以外的其他字符。</li>
</ul>
<h2 id="使用圆括号但不捕获其内容"><a class="header" href="#使用圆括号但不捕获其内容">使用圆括号，但不捕获其内容</a></h2>
<ul>
<li>有时候只想使用圆括号的分组功能，但并不关系捕获的子匹配。例如可以使用下面的模式来匹配作者名字的两种形式。</li>
</ul>
<pre><code>/\v(And|D)rew Neil
</code></pre>
<ul>
<li>如果不想捕获圆括号内的内容&quot;And&quot;或&quot;D&quot;,可以在圆括号前面加上%，指示Vim不要将括号内的内容赋值给寄存器\1</li>
</ul>
<pre><code>/\v%(And|D)rew Neil
</code></pre>
<ul>
<li>只有1个括号的情况下，上面2种方式似乎没有什么差别，但是有多个括号时，这种方法就很有用处了。</li>
<li>例如,想把所有的名和姓替换成姓和名:</li>
</ul>
<pre><code>/\v(%(And|D)rew) (Neil)
:s//\2, \1/g
</code></pre>
<ul>
<li>可以用\W\ze\w模拟元字符&lt;</li>
<li>可以用\w\ze\W表示元字符&gt;</li>
<li>在very magic 模式下，&lt;与&gt;字符可直接解析为单词定界符，magic,nomagic以及very nomagic 搜索模式下，必须将它们转义。</li>
<li>在Vim文档中查阅这些选项，得在前面附加一个转义符:</li>
</ul>
<pre><code>:h \&lt;
:h \&gt;
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="技巧78-界定匹配的边界"><a class="header" href="#技巧78-界定匹配的边界">技巧78-界定匹配的边界</a></h1>
<ul>
<li>有时候，可能想指定一个范围较广的模式，但只对匹配结果的一部分感兴趣。Vim中的元字符\zs与\ze可以帮助我们处理这种情况。</li>
<li>一个匹配的边界通常对应一个模式的起始与结尾。</li>
<li>可以使用元字符\zs与\ze对匹配进行裁剪。</li>
<li>与单词定界符类似，\zs与\ze均为零宽度元字符。</li>
</ul>
<h2 id="例子"><a class="header" href="#例子">例子</a></h2>
<ul>
<li>查找Practical Vim 所有出现的地方都会被高亮</li>
</ul>
<pre><code>/Practical Vim&lt;CR&gt;
</code></pre>
<ul>
<li>查找Practical \zsVim 只有匹配项中的Vim会高亮</li>
</ul>
<pre><code>/Practical \zsVim
</code></pre>
<ul>
<li>匹配引号开始引号结尾</li>
</ul>
<pre><code>/\v&quot;[^&quot;]+&quot;&lt;CR&gt;
</code></pre>
<ul>
<li>匹配引号开头引号结尾高亮引号内的内容</li>
</ul>
<pre><code>/\v&quot;\zs[^&quot;]+\ze&quot;&lt;CR&gt;
</code></pre>
<ul>
<li>环视表达式</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="技巧79-转义问题字符"><a class="header" href="#技巧79-转义问题字符">技巧79-转义问题字符</a></h1>
<ul>
<li>\V 原义开关使得按原义查找文本变得更容易，因而. + 以及*的特殊含义被屏蔽掉了。但还有一些字符，其特殊含义无法被屏蔽。</li>
</ul>
<h2 id="正向查找时要转义字符"><a class="header" href="#正向查找时要转义字符">正向查找时要转义/字符</a></h2>
<ul>
<li>进行正向查找时，必须转义/字符。</li>
</ul>
<h2 id="反向查找时要转义字符"><a class="header" href="#反向查找时要转义字符">反向查找时要转义?字符</a></h2>
<ul>
<li>执行反向查找时，符号?会被当作查找域的结束符。要对?进行转义。</li>
</ul>
<h2 id="每次都要转义符号-"><a class="header" href="#每次都要转义符号-">每次都要转义符号 \</a></h2>
<ul>
<li>必须寨查找域中为每个反斜杠各添加一个反斜杠。</li>
</ul>
<h2 id="用编程的方式转义字符"><a class="header" href="#用编程的方式转义字符">用编程的方式转义字符</a></h2>
<ul>
<li>escape(@u,'/') 为每个/与\加上反斜杠前缀。</li>
<li>getcmdtype()</li>
<li>正向查找时getcmdtype().'' 将产生&quot;/&quot;</li>
<li>反向查找时getcmdtype().'' 将产生&quot;?&quot;</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="技巧80-结识查找命令"><a class="header" href="#技巧80-结识查找命令">技巧80-结识查找命令</a></h1>
<h3 id="1-执行一次查找"><a class="header" href="#1-执行一次查找">1. 执行一次查找</a></h3>
<ul>
<li>在普通模式按下 / 调出Vim的查找提示符，按下&lt;CR&gt;键时，Vim才会开始查找，按&lt;Esc&gt;退回到普通模式。</li>
<li>默认是循环查找的。</li>
<li>关闭循环查找：wrapscan 可以用:h wrapscan查看具体方法。</li>
</ul>
<h3 id="2-定制查找的方向"><a class="header" href="#2-定制查找的方向">2. 定制查找的方向</a></h3>
<ul>
<li>/  正向查找</li>
<li>？ 反向查找</li>
</ul>
<h3 id="3-重复上一次查找"><a class="header" href="#3-重复上一次查找">3. 重复上一次查找</a></h3>
<ul>
<li>n 命令 用于跳到下一处匹配</li>
<li>N 命令 用于跳到上一处匹配</li>
</ul>
<div class="table-wrapper"><table><thead><tr><th style="text-align: left">命令</th><th style="text-align: left">用途</th></tr></thead><tbody>
<tr><td style="text-align: left">n</td><td style="text-align: left">跳到下一处匹配</td></tr>
<tr><td style="text-align: left">N</td><td style="text-align: left">跳到上一处匹配</td></tr>
<tr><td style="text-align: left">gn</td><td style="text-align: left">进入面向字符的可视模式，并选中下一处匹配</td></tr>
<tr><td style="text-align: left">gN</td><td style="text-align: left">进入面向字符的可视模式，并选中上一处匹配</td></tr>
</tbody></table>
</div>
<h3 id="4-回溯之前的查找"><a class="header" href="#4-回溯之前的查找">4. 回溯之前的查找</a></h3>
<ul>
<li>&lt;Up&gt;键(我比较喜欢用C-p和C-n进行查找，方向键能不用就不用)</li>
<li>技巧34和技巧85中有讨论，后续会进行补充关联</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="技巧81-高亮查找匹配"><a class="header" href="#技巧81-高亮查找匹配">技巧81-高亮查找匹配</a></h1>
<ul>
<li>Vim可以高亮查找匹配，但该功能在缺省情况下并没有被激活。</li>
<li>启用hlsearch 可以高两匹配。</li>
</ul>
<h2 id="禁用高亮查找功能"><a class="header" href="#禁用高亮查找功能">禁用高亮查找功能</a></h2>
<ul>
<li>高亮查找功能非常有用，但它有时却不太受欢迎。</li>
<li>禁用高亮查找功能:</li>
</ul>
<pre><code>:set nohlsearch
或
:se hls!
</code></pre>
<ul>
<li>临时关闭查找高亮，直到下次查找</li>
</ul>
<pre><code>:nohlsearch
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="技巧82-在执行前查找当前预览第一处匹配"><a class="header" href="#技巧82-在执行前查找当前预览第一处匹配">技巧82-在执行前查找当前预览第一处匹配</a></h1>
<ul>
<li>incsearch 允许在没有执行回车前提前预览查找项。</li>
<li>.vimrc中配置永久生效</li>
</ul>
<pre><code>set incsearch
</code></pre>
<ul>
<li>
<p>按Esc能退出预览，光标回到原来位置</p>
</li>
<li>
<p>提前预览可以用来检查是否存在一处匹配</p>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="技巧83-将光标偏移到查找匹配的结尾"><a class="header" href="#技巧83-将光标偏移到查找匹配的结尾">技巧83-将光标偏移到查找匹配的结尾</a></h1>
<ul>
<li>查找时将光标置于lang结尾的方法</li>
</ul>
<pre><code>/lang/e/&lt;CR&gt;
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="技巧84-对完整的查找匹配进行操作"><a class="header" href="#技巧84-对完整的查找匹配进行操作">技巧84-对完整的查找匹配进行操作</a></h1>
<ul>
<li>Vim的查找命令允许高亮所有匹配并在它们之间跳转。</li>
<li>通过gn命令可以对匹配当前模式的文本进行操作。（Vim7.4.110后支持）</li>
<li>\C强行匹配大小写。</li>
<li>gUgn将查找的匹配项转为大写。再按点重复执行。</li>
<li>dgn删除查找匹配项。按点命令重复执行。</li>
<li>例如想吧logger.ELOG 改为ELOG:</li>
</ul>
<pre><code>/logger.&lt;CR&gt;
dgn
.
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="技巧85-利用查找历史迭代完成复杂的模式"><a class="header" href="#技巧85-利用查找历史迭代完成复杂的模式">技巧85-利用查找历史，迭代完成复杂的模式</a></h1>
<ul>
<li>匹配单引号内部任意字符</li>
</ul>
<pre><code>/\v '.+'
</code></pre>
<ul>
<li>.+执行了贪婪匹配，它匹配了尽可能多的字符。</li>
<li>匹配单引号内部任意字符(单引号除外)</li>
</ul>
<pre><code>/\v'.[^']+'
</code></pre>
<ul>
<li>匹配单引号内部任意字符(非组成单词的单引号除外)</li>
</ul>
<pre><code>/\v'([^']|'\w)+'
</code></pre>
<ul>
<li>查看之前的查找命令</li>
</ul>
<pre><code>q/
</code></pre>
<ul>
<li>将匹配引号括起来的内容保存在\1寄存器中</li>
</ul>
<pre><code>/\v'(([^']|'\w)+)'
</code></pre>
<ul>
<li>替换查找的内容,单引号换成双引号</li>
</ul>
<pre><code>:%s//&quot;\1&quot;/g
</code></pre>
<ul>
<li>
<p>将查找域留空，Vim将重用上一此的查找命令</p>
</li>
<li>
<p>完整替换命令</p>
</li>
</ul>
<pre><code>:%s//\v'(([^']|'\w)+)'/&quot;\1&quot;/g
</code></pre>
<h2 id="总结-10"><a class="header" href="#总结-10">总结</a></h2>
<ul>
<li>正则表达式用法,匹配成对单引号的方法:/\v'.+'</li>
<li>将查找域留空，Vim将重用上一此的查找命令 </li>
<li>使用<Up>查看历史查找或使用q/查看历史查找，逐步改进命令，使用incsearch来预先查看搜索。最终达到目的。</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="技巧86-统计当前模式的匹配个数"><a class="header" href="#技巧86-统计当前模式的匹配个数">技巧86-统计当前模式的匹配个数</a></h1>
<ul>
<li>方法1:</li>
</ul>
<pre><code>/DLOG
:%s///gn
</code></pre>
<ul>
<li>方法2</li>
<li>其中%表示只在当前文件查找</li>
<li>模式域留空的目的是让:vimgrep使用当前查找的模式。</li>
</ul>
<pre><code>/DLOG
:vimgrep //g %
</code></pre>
<ul>
<li>方法3:</li>
</ul>
<pre><code>:cnext
:cprev
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="技巧87-查找当前高亮选区中的文本"><a class="header" href="#技巧87-查找当前高亮选区中的文本">技巧87-查找当前高亮选区中的文本</a></h1>
<ul>
<li>在普通模式下，*命令可以查找光标下的单词。</li>
</ul>
<h2 id="在可视模式下查找当前单词"><a class="header" href="#在可视模式下查找当前单词">在可视模式下查找当前单词</a></h2>
<ul>
<li>在可视模式下，*命令将查找光标下的单词。</li>
<li>可视模式下，使用visual star search插件</li>
<li>:h mapmode-x</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="技巧88-认识substitute命令"><a class="header" href="#技巧88-认识substitute命令">技巧88-认识substitute命令</a></h1>
<p><code>substitute</code>命令允许先查找一段文本，再用另一段文本将其替换掉。命令语法如下:</p>
<pre><code>:[range]s[ubstitue]/{pattern}/{string}/[flags]
</code></pre>
<p><code>[range]</code>对每一条<code>Ex</code>命令都有效</p>
<h2 id="利用标志位调整substitute命令的行为"><a class="header" href="#利用标志位调整substitute命令的行为">利用标志位调整<code>substitute</code>命令的行为</a></h2>
<ul>
<li>标志位<code>g</code>:使得<code>substitue</code>命令可以在全局范围内执行。</li>
<li>标志位<code>c</code>:让我们有机会确认或拒绝每一次修改。</li>
<li>标志位<code>n</code>:会抑制正常的替换行为，即让Vim不执行替换操作，而只报告本次命令匹配的个数。</li>
<li>标志位<code>e</code>:屏蔽错误提示。</li>
<li>标志位<code>&amp;</code>:让Vim重用上一次的标志位。</li>
</ul>
<div class="table-wrapper"><table><thead><tr><th style="text-align: left">flag</th><th style="text-align: left">含义</th><th style="text-align: left">例子</th></tr></thead><tbody>
<tr><td style="text-align: left">g</td><td style="text-align: left">使得substitute命令在全局范围内执行</td><td style="text-align: left">技巧89</td></tr>
<tr><td style="text-align: left">c</td><td style="text-align: left">每处修改进行询问</td><td style="text-align: left">技巧90</td></tr>
<tr><td style="text-align: left">n</td><td style="text-align: left">抑制正常的替换行为</td><td style="text-align: left">技巧86</td></tr>
<tr><td style="text-align: left">e</td><td style="text-align: left">屏蔽错误提示</td><td style="text-align: left">-</td></tr>
<tr><td style="text-align: left">&amp;</td><td style="text-align: left">指示Vim重用上一次substitute命令所用过的标志位</td><td style="text-align: left">技巧93</td></tr>
</tbody></table>
</div>
<h2 id="替换域中的特殊字符"><a class="header" href="#替换域中的特殊字符">替换域中的特殊字符</a></h2>
<p>使用<code>:h sub-replace-special</code> 查看特殊字符的完整列表</p>
<p>部分常用符号</p>
<div class="table-wrapper"><table><thead><tr><th style="text-align: left">符号</th><th style="text-align: left">描述</th><th style="text-align: left">例子</th></tr></thead><tbody>
<tr><td style="text-align: left">\r</td><td style="text-align: left">插入一个换行符</td><td style="text-align: left">-</td></tr>
<tr><td style="text-align: left">\t</td><td style="text-align: left">插入一个制表符</td><td style="text-align: left">-</td></tr>
<tr><td style="text-align: left">\</td><td style="text-align: left">插入一个反斜杠</td><td style="text-align: left">-</td></tr>
<tr><td style="text-align: left">\1</td><td style="text-align: left">插入第1个子匹配</td><td style="text-align: left">技巧94</td></tr>
<tr><td style="text-align: left">\2</td><td style="text-align: left">插入第2个子匹配</td><td style="text-align: left">技巧94</td></tr>
<tr><td style="text-align: left">\0</td><td style="text-align: left">插入匹配模式的所有内容</td><td style="text-align: left">-</td></tr>
<tr><td style="text-align: left">&amp;</td><td style="text-align: left">插入匹配模式的所有内容</td><td style="text-align: left">-</td></tr>
<tr><td style="text-align: left">~</td><td style="text-align: left">使用上一次调用:substitute时的{string}</td><td style="text-align: left">技巧93</td></tr>
<tr><td style="text-align: left">\={Vim script}</td><td style="text-align: left">执行{Vim script}表达式；并将返回的结果作为替换{string}</td><td style="text-align: left">技巧95，技巧96</td></tr>
</tbody></table>
</div>
<p><a href="https://cfanzp.com">返回</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="技巧89-在文件范围内查找并替换每一处匹配"><a class="header" href="#技巧89-在文件范围内查找并替换每一处匹配">技巧89-在文件范围内查找并替换每一处匹配</a></h1>
<p>将文件中的going都替换成rolling</p>
<pre><code>:%s/going/rolling/g
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="技巧90-手动控制每一次替换操作"><a class="header" href="#技巧90-手动控制每一次替换操作">技巧90-手动控制每一次替换操作</a></h1>
<p>将content替换成copy并确认是否修改</p>
<pre><code>:%s/content/copy/gc
</code></pre>
<ul>
<li>
<p><code>y</code> 替换此处匹配</p>
</li>
<li>
<p><code>n</code> 忽略此处匹配</p>
</li>
<li>
<p><code>q</code> 退出替换过程</p>
</li>
<li>
<p><code>l</code> 替换此处匹配后退出</p>
</li>
<li>
<p><code>a</code> 替换此处与之后的所有的匹配</p>
</li>
<li>
<p><code>&lt;C-e&gt;</code> 向上滚动屏幕</p>
</li>
<li>
<p><code>&lt;C-y&gt;</code> 向下滚动屏幕</p>
</li>
<li>
<p>查看帮助</p>
</li>
</ul>
<pre><code>:h s_c
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="技巧91-重用上次的查找模式"><a class="header" href="#技巧91-重用上次的查找模式">技巧91-重用上次的查找模式</a></h1>
<ul>
<li>将<code>substitute</code>命令的查找域留空，意味着Vim将会重用上次的查找模式。</li>
<li><code>&lt;C-r&gt;&lt;C-w&gt;</code> 粘贴光标当前内容</li>
<li><code>&lt;C-r&gt;/</code>粘贴上次查找内容</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="技巧92-用寄存器的内容替换"><a class="header" href="#技巧92-用寄存器的内容替换">技巧92-用寄存器的内容替换</a></h1>
<p>1.<code> &lt;C-r&gt;{register},</code>可以将寄存器的内容插入命令行。</p>
<p>2.用复制专用寄存器的内容替换上一次的模式</p>
<pre><code>:%s//\=@0/g
</code></pre>
<p>3.将选中的内容存入a寄存器</p>
<pre><code>&quot;ay
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="技巧93-重复上一次substitute命令"><a class="header" href="#技巧93-重复上一次substitute命令">技巧93-重复上一次substitute命令</a></h1>
<ul>
<li><code>g&amp;</code>在整个文件范围内重复上一次命令</li>
<li><code>gv</code>命令激活可视模式，并重新将上次被选中的文本高亮起来。</li>
<li><code>:%&amp;&amp;</code>在整个文件范围内重复执行上一个查找替换命令。</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="技巧94-使用子匹配重排csv文件的字段"><a class="header" href="#技巧94-使用子匹配重排csv文件的字段">技巧94-使用子匹配重排CSV文件的字段</a></h1>
<p>例子:</p>
<pre><code>last name,first name,emial
san,zhang,zhang san@qq.com
si,li,lisi@qq.com
wang,wu,wangwu@qq.com
</code></pre>
<p>重排:</p>
<pre><code>/\v^([^,]*),([^,]*),([^,]*)$
:%s//\3,\2,\1
</code></pre>
<p><code>\1</code>:匹配姓氏，<code>\2</code>:匹配名字，<code>\3</code>:匹配电子邮箱。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="技巧95-在替换过程中执行算术运算"><a class="header" href="#技巧95-在替换过程中执行算术运算">技巧95-在替换过程中执行算术运算</a></h1>
<p>文档:</p>
<pre><code>&lt;h2&gt;Heading number 1&lt;/h2&gt;
&lt;h3&gt;number 2 heading&lt;/h3&gt;
&lt;h4&gt;Another heading&lt;/h4&gt;
</code></pre>
<p>修改:</p>
<pre><code>/\v\&lt;/?h\zs\d
:%s//\=submatch(0)-1/g
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="技巧96-交换两个或更多的单词"><a class="header" href="#技巧96-交换两个或更多的单词">技巧96-交换两个或更多的单词</a></h1>
<p>文本:</p>
<pre><code>The dog bit the man.
</code></pre>
<p>想把dog和man互换:</p>
<pre><code>\v(&lt;man&gt;|&lt;dog&gt;)
:%s//\={&quot;dog&quot;:&quot;man&quot;,&quot;man&quot;:&quot;dog&quot;}[submatch(1)]/g
</code></pre>
<h2 id="使用abolishvim超级substitue命令"><a class="header" href="#使用abolishvim超级substitue命令">使用Abolish.vim：超级substitue命令</a></h2>
<p>Subvert命令，简写为<code>:S</code></p>
<pre><code>:%S/{man,dog}/{dog,man}/g
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="技巧97-在多个文件中执行查找与替换"><a class="header" href="#技巧97-在多个文件中执行查找与替换">技巧97-在多个文件中执行查找与替换</a></h1>
<ul>
<li>例子:把Pragmatic Vim 都改成Practical Vim</li>
</ul>
<pre><code>/Pragmatic\ze Vim
</code></pre>
<ul>
<li>元字符\ze把单词Vim从匹配中排除掉（见技巧78),然后运行substitute命令</li>
</ul>
<pre><code>:%s//Practical/g
</code></pre>
<h2 id="使用vimgrep在工程范围内查找"><a class="header" href="#使用vimgrep在工程范围内查找">使用:vimgrep在工程范围内查找</a></h2>
<pre><code>/Pragmatic\ze Vim
:vimgrep // **/*.txt
</code></pre>
<ul>
<li>查找域留空，Vim使用当前的查找模式</li>
<li>通配符**/*.txt,匹配当前目录下的所有后缀为.txt的文件</li>
</ul>
<h2 id="使用cfdo在整个工程范围内执行substitute命令"><a class="header" href="#使用cfdo在整个工程范围内执行substitute命令">使用:cfdo在整个工程范围内执行substitute命令</a></h2>
<ul>
<li>设置hidden</li>
<li>该项设置可以无需存盘就可以从莫个被修改的文件中切换出去。</li>
</ul>
<pre><code>：set hidden
</code></pre>
<ul>
<li>批量替换</li>
</ul>
<pre><code>:cfdo %s//Practical/gc
</code></pre>
<ul>
<li>批量存盘</li>
</ul>
<pre><code>:cfdo update
</code></pre>
<ul>
<li>合并修改存盘</li>
</ul>
<pre><code>:cfdo %s//Practical/g | update
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="技巧98-认识global命令"><a class="header" href="#技巧98-认识global命令">技巧98-认识global命令</a></h1>
<ul>
<li>:global 命令允许在摸个指定模式的所有匹配行上允许Ex命令。</li>
<li>:global命名通常采用以下形式(参见:h :g)</li>
</ul>
<pre><code>:[range] global[!] /{pattern}/ [cmd]
</code></pre>
<ul>
<li>在缺省情况下，:global命令的作用范围是整个文件(%).</li>
<li>{pattern} 域与查找历史相互关联，如果留空，Vim自动使用当前查找模式</li>
<li>[cmd] 可以使除:global 命令之外的任何 Ex 命令。 默认为:print</li>
<li>:global! 或者:vglobal 反转(v表示invert)</li>
<li>:global 命令在指定[range]内的文本行执行时通常分为两轮：
<ol>
<li>第一轮，Vim在所有[pattern]的匹配行首做上标记。</li>
<li>第二轮，再在所有已标记的文本上执行[cmd]。</li>
</ol>
</li>
<li>[cmd]的范围可以单独设定。</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="技巧99-删除所有包含模式的文本行"><a class="header" href="#技巧99-删除所有包含模式的文本行">技巧99-删除所有包含模式的文本行</a></h1>
<ul>
<li>将:global命令与:delete命令组合使用，可以快速裁剪文件内容。</li>
</ul>
<h2 id="用gred-删除所有匹配"><a class="header" href="#用gred-删除所有匹配">用'：g/re/d' 删除所有匹配</a></h2>
<ul>
<li>文本</li>
</ul>
<pre><code class="language-html">&lt;ol&gt;
&lt;li&gt;
&lt;a href=&quot;cfanzp.csdn.net/&quot;&gt;
show cfanzp blog1
&lt;/a&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;a href=&quot;cfanzp.csdn.net/&quot;&gt;
show cfanzp blog2
&lt;/a&gt;
&lt;/li&gt;
&lt;/ol&gt;
</code></pre>
<ul>
<li>执行命令</li>
</ul>
<pre><code>/\v\&lt;\/?\w+&gt;
:g//d
</code></pre>
<ul>
<li>执行后文本</li>
</ul>
<pre><code>show cfanzp blog1
show cfanzp blog2
</code></pre>
<ul>
<li>与:substitue命令类似，也可将:global命令的查找域留空。</li>
<li>\v 开启very magic模式</li>
<li>&lt; 匹配&lt;</li>
<li>/? 匹配可选的正斜杠</li>
<li>\w+ 匹配一个或多个单词</li>
<li>
<blockquote>
<p>匹配单词结尾的分隔符&gt;</p>
</blockquote>
</li>
</ul>
<h3 id="grep的来历"><a class="header" href="#grep的来历">grep的来历</a></h3>
<ul>
<li>global命令的简写形式</li>
<li>re表示regular expression</li>
<li>p 是:print的缩写</li>
<li>/去掉就是grep</li>
</ul>
<pre><code>:g/re/p
</code></pre>
<h2 id="用vred-之保留匹配行"><a class="header" href="#用vred-之保留匹配行">用':v/re/d' 之保留匹配行</a></h2>
<ul>
<li>删除所有不包含cfanzp的行</li>
<li>vgroup 简写为v </li>
</ul>
<pre><code>:v/cfanzp/d
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="技巧100-将todo项收集至寄存器"><a class="header" href="#技巧100-将todo项收集至寄存器">技巧100-将TODO项收集至寄存器</a></h1>
<ul>
<li>:global和:yank 结合可以解决这个问题
<ul>
<li>用大写的A是附加到寄存器a(追加)，小写的a会覆盖寄存器a</li>
<li>&quot;ap 可以将a寄存器的内容粘贴出去。</li>
</ul>
</li>
</ul>
<pre><code>:g/TODO/yank A
:reg a
</code></pre>
<ul>
<li>将所有的TODO项复制到文件结尾</li>
</ul>
<pre><code>:g/TODO/t$
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="技巧101-将css文件中所有规则的属性按字母排序"><a class="header" href="#技巧101-将css文件中所有规则的属性按字母排序">技巧101 将CSS文件中所有规则的属性按字母排序</a></h1>
<h2 id="对单条规则的属性进行排序"><a class="header" href="#对单条规则的属性进行排序">对单条规则的属性进行排序</a></h2>
<ul>
<li>文本</li>
</ul>
<pre><code class="language-css">html {
    margin:0;
    padding:0;
    border:0;
}
</code></pre>
<ul>
<li>执行命令</li>
</ul>
<pre><code>vi{
:'&lt;,'&gt;sort
</code></pre>
<ul>
<li>执行后文本</li>
</ul>
<pre><code class="language-css">html {
    border:0;
    margin:0;
    padding:0;
}
</code></pre>
<h2 id="对所有规则的属性进行排序"><a class="header" href="#对所有规则的属性进行排序">对所有规则的属性进行排序</a></h2>
<ul>
<li>:g/{pattern}/[range][cmd]</li>
</ul>
<pre><code>:g/{/ .+1,/}/-1 sort
</code></pre>
<ul>
<li>
<p>上例分析</p>
<ul>
<li>.符号代表当前行</li>
<li>+1,-1代表偏移量</li>
<li>.,/}/ 表示从当前行开始，一直匹配模式/}/的那一行为止。</li>
</ul>
</li>
<li>
<p>:global命令的广义形式</p>
</li>
</ul>
<pre><code>:g/{start}/ .,{finish} [cmd]
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="技巧102-认识ctags"><a class="header" href="#技巧102-认识ctags">技巧102-认识ctags</a></h1>
<h3 id="1-安装ctags"><a class="header" href="#1-安装ctags">1. 安装ctags</a></h3>
<ul>
<li>安装ctags</li>
</ul>
<pre><code>sudo apt-get install ctags
</code></pre>
<ul>
<li>查看安装版本</li>
</ul>
<pre><code>ctags --version
</code></pre>
<h3 id="2-用ctags-创建代码库的索引产生一个tags标签文件文件"><a class="header" href="#2-用ctags-创建代码库的索引产生一个tags标签文件文件">2. 用ctags 创建代码库的索引产生一个tags标签文件文件</a></h3>
<pre><code>ctags *
</code></pre>
<h3 id="3-详解标签文件"><a class="header" href="#3-详解标签文件">3. 详解标签文件</a></h3>
<ul>
<li>标签文件的前几行由元数据组成。而此后的没一行文本均由关键字、文件名以及关键字在源代码中的位置这3项内容构成。</li>
<li>关键字是按照字母顺序排列的。</li>
</ul>
<h3 id="4-用模式定位关键字而不是用行号"><a class="header" href="#4-用模式定位关键字而不是用行号">4. 用模式定位关键字，而不是用行号</a></h3>
<ul>
<li>ctags 不采用绝对行号，而是用查找命令定位每一处关键字</li>
</ul>
<h3 id="5-用元数据标记关键字"><a class="header" href="#5-用元数据标记关键字">5. 用元数据标记关键字</a></h3>
<ul>
<li>目前使用的扩展格式，允许在末尾添加额外字段，为关键字提供元数据。</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="技巧103-配置vim使用ctags"><a class="header" href="#技巧103-配置vim使用ctags">技巧103-配置Vim使用ctags</a></h1>
<ul>
<li>生成ctags文件</li>
</ul>
<pre><code>:!ctags -R
</code></pre>
<ul>
<li>添加键盘映射,按F5就可以更新索引。</li>
</ul>
<pre><code>:nnormap &lt;f5&gt; :!ctags -R&lt;CR&gt;
</code></pre>
<h2 id="在每次保存文件时自动执行ctags"><a class="header" href="#在每次保存文件时自动执行ctags">在每次保存文件时自动执行ctags</a></h2>
<pre><code>:autocmd BufWritePost * call system(&quot;ctags -R&quot;)
</code></pre>
<h2 id="通过版本控制工具的回调机制自动执行ctags"><a class="header" href="#通过版本控制工具的回调机制自动执行ctags">通过版本控制工具的回调机制自动执行ctags</a></h2>
<ul>
<li>在Tim Pope的&lt;<Effortless Ctags with Git>&gt; 一文中，讲解了如何为post-commit、post-merge 以及post-checkout等事件建立回调机制。</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="技巧104-使用vim的标签跳转命令浏览关键字的定义"><a class="header" href="#技巧104-使用vim的标签跳转命令浏览关键字的定义">技巧104-使用Vim的标签跳转命令，浏览关键字的定义</a></h1>
<ul>
<li>Vim与ctags的集成，使得代码中的关键字变成了某种形式的超链接。</li>
</ul>
<h2 id="跳转到关键字的定义处"><a class="header" href="#跳转到关键字的定义处">跳转到关键字的定义处</a></h2>
<pre><code>&lt;C-]&gt;
</code></pre>
<ul>
<li>后退返回</li>
</ul>
<pre><code>&lt;C-t&gt;
</code></pre>
<h2 id="关键字存在多处匹配时可以指定跳转的位置"><a class="header" href="#关键字存在多处匹配时可以指定跳转的位置">关键字存在多处匹配时，可以指定跳转的位置。</a></h2>
<ul>
<li>g&lt;C-]&gt;命令会从标签匹配列表中挑出可选项供我们选择。</li>
<li>只需要输入相应的数字并按下<CR>键。</li>
</ul>
<pre><code>g&lt;C-]&gt;
</code></pre>
<ul>
<li>也可以使用tselect</li>
</ul>
<pre><code>:tselect
:tprev
:tfirst
:tlast
</code></pre>
<ul>
<li>可以参考unimpaired插件</li>
</ul>
<h2 id="使用ex命令"><a class="header" href="#使用ex命令">使用Ex命令</a></h2>
<pre><code>:tag {keyword} 跳转到匹配{keyword}的第一处标签。
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="技巧105-不用离开vim也能编译代码"><a class="header" href="#技巧105-不用离开vim也能编译代码">技巧105-不用离开Vim也能编译代码</a></h1>
<h3 id="在vim中编译工程"><a class="header" href="#在vim中编译工程">在Vim中编译工程</a></h3>
<ul>
<li>在c或c++工程中，进入Makefile所在目录，然后在命令行模式输入:make 即可编译工程。</li>
<li>:make! 结尾的!将指示Vim只更新quickfix列表，而不跳到第一处错误。</li>
<li>:cnext 可以跳转到quickfix列表的下一出错位置。</li>
<li>:copen 可以打开quickfix列表。</li>
<li>:h quickfix 查看quickfix帮助。</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="技巧106-浏览quickfix列表"><a class="header" href="#技巧106-浏览quickfix列表">技巧106-浏览Quickfix列表</a></h1>
<ul>
<li>quickfix 列表会保存一组针对单个或多个文件内容的位置信息。</li>
<li>查看帮助</li>
</ul>
<pre><code>:h quickfix
</code></pre>
<ul>
<li>填充quickfix列表的一些命令</li>
</ul>
<pre><code>:make
:grep
:vimgrep
:Ag
</code></pre>
<ul>
<li>浏览Quickfix列表的命令</li>
</ul>
<div class="table-wrapper"><table><thead><tr><th>命令</th><th>用途</th></tr></thead><tbody>
<tr><td>:cnext</td><td>跳到下一项</td></tr>
<tr><td>:cprev</td><td>跳转到上一项</td></tr>
<tr><td>:cfirst</td><td>跳转到第一项</td></tr>
<tr><td>:clast</td><td>跳转到最后一项</td></tr>
<tr><td>:cnfile</td><td>跳转到下一个 文件中的第一项</td></tr>
<tr><td>:cpfile</td><td>跳转到上一个文件的最后一项</td></tr>
<tr><td>:cc N</td><td>跳转到第N项</td></tr>
<tr><td>:copen</td><td>打开quickfix窗口</td></tr>
<tr><td>:cclose</td><td>关闭quickfix窗口</td></tr>
<tr><td>:cdo {cmd}</td><td>在quickfix列表中的每一行执行{cmd}</td></tr>
<tr><td>:cfdo {cmd}</td><td>在quickfix列表中的每一个文件执行{cmd}</td></tr>
</tbody></table>
</div>
<h2 id="结实位置列表"><a class="header" href="#结实位置列表">结实位置列表</a></h2>
<ul>
<li>位置列表要多少有多少，但是特定时刻只有一个quickfix列表。</li>
<li>以下命令会使用位置列表</li>
</ul>
<pre><code>:lmake
:lgrep
:lvimgrep
</code></pre>
<h2 id="quickfix的基本移动命令"><a class="header" href="#quickfix的基本移动命令">Quickfix的基本移动命令</a></h2>
<pre><code>:cnext
:cprevious(cprev)
:cfirst
:clast
</code></pre>
<ul>
<li>插件 unimpaired</li>
</ul>
<h2 id="quickfix的快速前进后退命令"><a class="header" href="#quickfix的快速前进后退命令">Quickfix的快速前进/后退命令</a></h2>
<ul>
<li>cnext,cprev前面可以附加执行次数，例如</li>
</ul>
<pre><code>:5cnext 每次间隔5项进行浏览
</code></pre>
<h2 id="使用quickfix窗口"><a class="header" href="#使用quickfix窗口">使用Quickfix窗口</a></h2>
<ul>
<li>运行:copen，可以打开一个包含quickfix列表内容的窗口</li>
<li>quickfix窗口中可以使用k,j进行上下滚动</li>
<li>在光标置于某匹配行时，<CR>键按下，将会打开相应的文件</li>
<li>:q 可以推出quickfix</li>
<li>:cclose 也可关闭quickfix</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="技巧107-回溯以前的quickfix列表"><a class="header" href="#技巧107-回溯以前的quickfix列表">技巧107-回溯以前的Quickfix列表</a></h1>
<ul>
<li>运行:colder命令可以回溯quickfix列表之前的某个版本（Vim会保存最近10个列表）。</li>
<li>从旧的quickfix列表回到比较新的列表，可以运行cnewer。</li>
<li>colder,cnewer都支持次数，例如:</li>
</ul>
<pre><code>:3coder
:5cnewer
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="技巧108-定制外部编译器"><a class="header" href="#技巧108-定制外部编译器">技巧108-定制外部编译器</a></h1>
<ul>
<li>Vim的:make命令不限于调用外部的make程序，也可以调用任何安装在机器上的编译器。</li>
</ul>
<h2 id="配置vim使其在运行make时可以调用nodelint即jslint的命令接口"><a class="header" href="#配置vim使其在运行make时可以调用nodelint即jslint的命令接口">配置Vim,使其在运行:make时可以调用nodelint,即JSLint的命令接口。</a></h2>
<ul>
<li>nodelint依赖Node.js,可以通过NPM命令进行安装</li>
</ul>
<pre><code>npm install nodelint -g
</code></pre>
<ul>
<li>makeprg 选项运行指定运行:make时调用的程序，帮助:h 'makeparg'</li>
<li>通过以下命令，可以指示Vim运行nodelint</li>
<li>其中%将被扩展成当前文件所在的路径</li>
</ul>
<pre><code>：setlocal makeprg=NODE_DISABLE_COLORS=1\ nodelint\ %
</code></pre>
<ul>
<li>如果当前正在编辑~/quickfix/cfanzp_test.js,则在Vim中运行:make,等价于在shell中运行以下命令</li>
</ul>
<pre><code>export NODE_DISABLE_COLORS=1
nodelint ~/quickfix/cfanzp_test.js
</code></pre>
<ul>
<li>在默认情况下，nodelint采用ANSI色标编码把错误信息高亮为红色。</li>
<li>配置NODE_DISABLE_COLORS=1 将会禁用颜色高亮，这样可以更容易地解析出错信息。</li>
</ul>
<h2 id="用nodelint的输出结构填充quickfix列表"><a class="header" href="#用nodelint的输出结构填充quickfix列表">用Nodelint的输出结构填充Quickfix列表</a></h2>
<ul>
<li>errorformat选项允许我们指导Vim如何解析由:make产生的输出结果。</li>
<li>参见：h 'errorformat'</li>
<li>查看选项的默认值:</li>
</ul>
<pre><code>:setglobal errorformat?
</code></pre>
<ul>
<li>lua demo:</li>
<li>%f 表示文件名</li>
<li>%l 表示行号</li>
<li>%m 表示错误信息</li>
</ul>
<pre><code>errorformat=%*[^&quot;]&quot;%f&quot;%*\D%l: %m,&quot;%f&quot;%*\D%l: %m,%-G%f:%l: (Each undeclared identifier is reported only once,%-G%f:%l: for each function it appears in.),%-GIn file included from %f:%l:%c:,%-GIn file included from %f:%l:%c\,,%-GIn file included from %f:%l:%c,%-GIn file included from %f:%l,%-G%*[ ]from %f:%l:%c,%-G%*[ ]from %f:%l:,%-G%*[ ]from %f:%l\,,%-G%*[ ]from %f:%l,%f:%l:%c:%m,%f(%l):%m,%f:%l:%m,&quot;%f&quot;\, line %l%*\D%c%*[^ ] %m,%D%*\a[%*\d]: Entering directory %*[`']%f',%X%*\a[%*\d]: Leaving directory %*[`']%f',%D%*\a: Entering directory %*[`']%f',%X%*\a: Leaving directory %*[`']%f',%DMaking %*\a in %f,%f|%l| %m
</code></pre>
<ul>
<li>可以使用setlocal 来设置错误格式的选项</li>
</ul>
<h2 id="用一条命令设置-makeprg-与-errorformat"><a class="header" href="#用一条命令设置-makeprg-与-errorformat">用一条命令设置 makeprg 与 errorformat</a></h2>
<ul>
<li>errorformat的配置太难记了。</li>
<li>可以将其保存到某个文件并使用:compiler命令来激活它。</li>
<li>帮助 :h :compiler</li>
</ul>
<pre><code>:compiler nodelint
</code></pre>
<ul>
<li>通过运行以下命令，可以对Vim自带的编译器插件了解得更透彻。</li>
</ul>
<pre><code>:args $VIMRUNTIME/compiler/*.vim
                            ```
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="技巧109-不必离开vim也能调用grep"><a class="header" href="#技巧109-不必离开vim也能调用grep">技巧109-不必离开Vim也能调用grep</a></h1>
<ul>
<li>Vim的grep命令给外部的grep程序提供了一层封装。</li>
<li>通过grep在多个文件中查找摸个模式，然后就可以用quickfix列表浏览这些查找结果了。</li>
</ul>
<h3 id="vim内部调用grep"><a class="header" href="#vim内部调用grep">Vim内部调用grep</a></h3>
<ul>
<li>:grepWaldo *  Vim将在后台为我们再shell中执行 grep -n Waldo *,创建一个quickfix列表。</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="技巧110-定制grep程序"><a class="header" href="#技巧110-定制grep程序">技巧110-定制grep程序</a></h1>
<ul>
<li>vim的:grep 是外部grep程序的包装。
<ul>
<li>配置grepprg与grepformat可以对vim的grep进行定制。</li>
</ul>
</li>
</ul>
<h2 id="vim默认的grep设置"><a class="header" href="#vim默认的grep设置">vim默认的grep设置</a></h2>
<pre><code>'grepformat' 'gfm'      string  (default &quot;%f:%l:%m,%f:%l%m,%f  %l%m&quot;)
'grepprg' 'gp'          string  (default &quot;grep -n &quot;,
                                 Unix: &quot;grep -n $* /dev/null&quot;,
                                 Win32: &quot;findstr /n&quot; or &quot;grep -n&quot;,
                                 VMS: &quot;SEARCH/NUMBERS &quot;)
</code></pre>
<h2 id="通过grep-调用ack"><a class="header" href="#通过grep-调用ack">通过:grep 调用ack</a></h2>
<ul>
<li>对比ack与grep:http://betterthangrep.com</li>
<li>ubuntu 中安装ack</li>
</ul>
<pre><code>sudo apt-get install ack-grep
sudo ln -s /usr/bin/ack-grep /usr/local/bin/ack
</code></pre>
<ul>
<li>OS X中使用Homebrew进行安装</li>
</ul>
<pre><code>brew install ack
</code></pre>
<ul>
<li>ack 实现grep -n的效果</li>
</ul>
<pre><code>ack --nogroup
</code></pre>
<ul>
<li>采用ack代替grep最简单的方法是把'grepprg'设置成以下值:</li>
</ul>
<pre><code>:set grepprg=ack\ --nogroup\ $*
</code></pre>
<h2 id="通过ack跳转到指定的行或列"><a class="header" href="#通过ack跳转到指定的行或列">通过ack跳转到指定的行或列</a></h2>
<ul>
<li>ack 采用--column参数运行ack时，它会给出每一处匹配的行号与列号。</li>
</ul>
<pre><code>ack --nogroup --column Waldo *
</code></pre>
<ul>
<li>修改grepprg和grepformat完成这一功能
<ul>
<li>%f表示文件名</li>
<li>%l表示行号</li>
<li>%c表示列号</li>
<li>%m表示匹配的文本</li>
</ul>
</li>
</ul>
<pre><code>:set grepprg=ack\ --nogroup\ --column\ $*
:set grepformat=%f:%l:%c:%m
</code></pre>
<h2 id="其他grep插件"><a class="header" href="#其他grep插件">其他grep插件</a></h2>
<ul>
<li>Ack.vim</li>
<li>fugitive.vim:Ggrep命令</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="技巧111-使用vim内置的正则表达式引擎的grep"><a class="header" href="#技巧111-使用vim内置的正则表达式引擎的grep">技巧111-使用Vim内置的正则表达式引擎的Grep</a></h1>
<ul>
<li>使用:vimgrep命令让Vim在所有文件中查找单词。</li>
<li>:vimgrep命令会把所有包含匹配项的行加入quickfix列表。</li>
<li>然后可以用:cnext,:cprev 浏览这些结果。</li>
</ul>
<pre><code>:vimgrep /going/ clock.txt tough.txt where.txt
:cnext
</code></pre>
<ul>
<li>模式域后加上g标志，:vimgrep就把所有匹配此模式的地方都列出来，而不仅仅时首处匹配。</li>
</ul>
<pre><code>:vimgrep /going/g clock.txt tough.txt where.txt
</code></pre>
<h2 id="指定查找哪些文件"><a class="header" href="#指定查找哪些文件">指定查找哪些文件</a></h2>
<ul>
<li>使用通配符*</li>
</ul>
<pre><code>:vim /going/g *.txt
</code></pre>
<ul>
<li>除了使用*和**通配符外还可以用##符号</li>
<li>
<h2 id="表示参数列表中的所有文件"><a class="header" href="#表示参数列表中的所有文件">表示参数列表中的所有文件;</a></h2>
</li>
<li>可以先把希望查找的文件加入参数列表;</li>
<li>然后在参数列表中的所有文件上运行:vimgrep。</li>
</ul>
<pre><code>:args *.txt
:vim /going/g ##
</code></pre>
<h2 id="先在文件内查找再扩大到整个工程"><a class="header" href="#先在文件内查找再扩大到整个工程">先在文件内查找，再扩大到整个工程</a></h2>
<ul>
<li>查找don't或 Don't</li>
</ul>
<pre><code>/[Dd]on't
:vim //g *.txt
</code></pre>
<h2 id="查找历史与vimgrep的关系"><a class="header" href="#查找历史与vimgrep的关系">查找历史与:vimgrep的关系</a></h2>
<ul>
<li>用当前查找模式在参数列表的文件中查找</li>
</ul>
<pre><code>:vim //g ##
</code></pre>
<ul>
<li>另外一种查找</li>
<li>如果想再次执行同一条:vimgrep命令，上述命令将很有用，因为它会把模式保存到命令历史中。</li>
</ul>
<pre><code>:vim /&lt;C-r&gt;//g ##
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="技巧112-认识vim的关键字自动补全"><a class="header" href="#技巧112-认识vim的关键字自动补全">技巧112-认识Vim的关键字自动补全</a></h1>
<h3 id="1-自动补全"><a class="header" href="#1-自动补全">1. 自动补全</a></h3>
<ul>
<li>Vim的自动补全可以再插入模式下触发。</li>
<li>ignorecase选项别启用后，自动补全时也会忽略大小写。可以用infercase 修正。</li>
</ul>
<h3 id="2-触发自动补全"><a class="header" href="#2-触发自动补全">2. 触发自动补全</a></h3>
<ul>
<li>&lt;C-p&gt;与&lt;C-n&gt; 可以再补全列表中反向或正向选择。</li>
<li>触发Vim 自动补全的方法总结</li>
</ul>
<div class="table-wrapper"><table><thead><tr><th style="text-align: left">命令</th><th style="text-align: left">补全类型</th></tr></thead><tbody>
<tr><td style="text-align: left">&lt;C-n&gt;</td><td style="text-align: left">普通关键字</td></tr>
<tr><td style="text-align: left">&lt;C-x&gt;&lt;C-n&gt;</td><td style="text-align: left">当前缓冲区关键字</td></tr>
<tr><td style="text-align: left">&lt;C-x&gt;&lt;C-i&gt;</td><td style="text-align: left">包含文件关键字</td></tr>
<tr><td style="text-align: left">&lt;C-x&gt;&lt;C-]&gt;</td><td style="text-align: left">标签文件关键字</td></tr>
<tr><td style="text-align: left">&lt;C-x&gt;&lt;C-k&gt;</td><td style="text-align: left">字典查找</td></tr>
<tr><td style="text-align: left">&lt;C-x&gt;&lt;C-l&gt;</td><td style="text-align: left">整行补全</td></tr>
<tr><td style="text-align: left">&lt;C-x&gt;&lt;C-o&gt;</td><td style="text-align: left">全能(Omni)补全</td></tr>
</tbody></table>
</div><div style="break-before: page; page-break-before: always;"></div><h1 id="技巧113-与自动补全的弹出式菜单进行交互"><a class="header" href="#技巧113-与自动补全的弹出式菜单进行交互">技巧113-与自动补全的弹出式菜单进行交互</a></h1>
<ul>
<li>不论使用哪种自动补全命令，都可以用<C-n>与<C-p>选择菜单中的上一项或下一项。。</li>
</ul>
<pre><code>&lt;C-n&gt;
&lt;C-p&gt;
&lt;Down&gt;
&lt;Up&gt;
&lt;C-y&gt; 确认使用当前选中的匹配项(yes)
&lt;C-e&gt; 还原最早输入的文本(从自动补全中exit)
&lt;C-h&gt;(与&lt;BS&gt;) 从当前匹配项中删除一个字符
&lt;C-l&gt; 从当前匹配字项中增加一个字符
{char} 中止自动补全并插入字符{char}
</code></pre>
<h2 id="浏览补全列表但不改变文档内容"><a class="header" href="#浏览补全列表但不改变文档内容">浏览补全列表，但不改变文档内容</a></h2>
<ul>
<li>使用<Down>/<Up>时，下/上一项将被选中，但是不会改变文档中的文本。</li>
<li>使用<CR>或者<C-y>将其插入到文档中。</li>
</ul>
<h2 id="滚动浏览补全列表的同时更新文档内容"><a class="header" href="#滚动浏览补全列表的同时更新文档内容">滚动浏览补全列表的同时更新文档内容</a></h2>
<ul>
<li><C-n>不仅可以选择列表中的项，而且会用选中的单词来更新文档。不用在按<CR>了。</li>
<li>我更倾向于使用<C-n>而不是<Down></li>
<li>手指不用离开本位键</li>
<li>不用多敲<CR></li>
</ul>
<h2 id="放弃所有选项"><a class="header" href="#放弃所有选项">放弃所有选项</a></h2>
<ul>
<li>使用<C-e>可以恢复到调用自动补全之前的状态。
<pre><code></code></pre>
</li>
</ul>
<p><C-e> (e可以记忆成end)
```</p>
<h2 id="随着输入字符的增多补全列表将得到精简"><a class="header" href="#随着输入字符的增多补全列表将得到精简">随着输入字符的增多，补全列表将得到精简</a></h2>
<ul>
<li>连续按<C-n><C-p></li>
<li><C-n>触发自动补全，并选中第一项。</li>
<li><C-p>选中补全列表的前一项，即在不关闭补全列表的情况下回到输入文本中。</li>
<li>这样可以继续输入，Vim将实时过滤补全列表。</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="技巧114-掌握关键字的来龙去脉"><a class="header" href="#技巧114-掌握关键字的来龙去脉">技巧114-掌握关键字的来龙去脉</a></h1>
<h2 id="缓冲区列表"><a class="header" href="#缓冲区列表">缓冲区列表</a></h2>
<ul>
<li>填充自动补全单词列表最简单的方法时使用当前缓冲区中的单词。</li>
<li>基于当前关键字的补全功能就是这样实现的，它可以通过<C-x><C-n>进行触发。</li>
<li>查看缓冲区列表</li>
</ul>
<pre><code>:ls!
</code></pre>
<h2 id="包含文件"><a class="header" href="#包含文件">包含文件</a></h2>
<ul>
<li>各语言外部文件或代码库加载代码
<ul>
<li>如果Vim建立补全列表时把它们加载起来，对我们大有裨益。</li>
<li>这恰好是<C-x><C-i> 触发关键字补全时发生的事。(:h compl-keyword)</li>
</ul>
</li>
</ul>
<pre><code>c #include
python import
ruby require
lua require
</code></pre>
<h2 id="标签文件"><a class="header" href="#标签文件">标签文件</a></h2>
<ul>
<li>ctags 生成标签文件tags</li>
<li>采用ctags建立代码库的索引，它让浏览代码变得更容易。</li>
<li>可以用<C-x>&lt;C-]&gt;命令调出自动补全。</li>
</ul>
<h2 id="合而为一"><a class="header" href="#合而为一">合而为一</a></h2>
<p>普通关键字自动补全，会把来自于缓冲区列表、包含文件以及标签文件的单词列表组合在一起，并生成补全建议。</p>
<ul>
<li>:h 'complete'</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="技巧115-使用字典中的单词进行自动补全"><a class="header" href="#技巧115-使用字典中的单词进行自动补全">技巧115-使用字典中的单词进行自动补全</a></h1>
<p>有时候，我们想通过自动补全功能输入某个单词，但是它并没有在任何打开的缓冲区、包含文件或标签文件中出现过。这种情况下，可以在字典中查找。</p>
<ul>
<li>:h compl-dictionary</li>
</ul>
<pre><code>&lt;C-x&gt;&lt;C-k&gt;
</code></pre>
<p>为了激活该功能，需要为Vim提供一份合适的单词列表。最简单的方法是运行下面的命令来激活Vim的拼写检查功能。</p>
<pre><code>:set spell
</code></pre>
<p>如果不想激活拼写检查功能，可以通过dictionary选项来指定一个或多个含有单词列表的文件。</p>
<ul>
<li>:h 'dictionary'
除此之外，还有一种通过拼写字典实现自动补全的方式。技巧123中介绍了其应用实例。</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="技巧116-自动补全整行文本"><a class="header" href="#技巧116-自动补全整行文本">技巧116-自动补全整行文本</a></h1>
<p>自动补全整行文本，vim中用<code>&lt;C-x&gt;&lt;C-l&gt;</code>触发</p>
<ul>
<li>:h compl-whole-line</li>
<li>普通关键字补全采用的文件也同样用于生成行自动补全建议列表。Vim会忽略行首的缩进。</li>
<li>面向行的自动补全功能妙就妙在不用知道要复制的行的具体位置，而只需要知道有这样一行额外那把存在即可。</li>
</ul>
<pre><code>&lt;C-x&gt;&lt;C-l&gt;
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="技巧117-自动补全单词序列"><a class="header" href="#技巧117-自动补全单词序列">技巧117-自动补全单词序列</a></h1>
<p>当使用自动补全功能补全单词时，Vim会记住该单词的来源位置。
如果紧接着再次调用自动补全功能，Vim就会插入位于其后的单词。
重复使用<code>&lt;C-x&gt;&lt;C-p&gt;</code>来完成补全。</p>
<p>Vim的自动补全不仅仅可以插入单词序列，也可以用于插入一系列的行。
如果重复使用<code>&lt;C-x&gt;&lt;C-l&gt;</code>命令，就可以插入文档其他位置上的若干各连续行。</p>
<p>能够自动补全连续的单词或行，通常能比复制粘贴更快得复制文本。
当你的搭档看到你在使用这一技术时，它们肯定会打断你，问你究竟时怎么做到的。 </p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="技巧118-自动补全文件名"><a class="header" href="#技巧118-自动补全文件名">技巧118-自动补全文件名</a></h1>
<p>Vim中的文件名自动补全功能可以通过<C-x><C-f>命令触发</p>
<pre><code>:h comple-filename
</code></pre>
<p>Vim的文件名自动补全功能只相对于工作目录的路径扩展，而不是相对于当前编辑文件的路径.</p>
<ul>
<li>理解这一点很重要。这一点会使得补全文件名，很多时候要在当前目录下才起作用。
<ul>
<li>先cd到补全目录</li>
<li>在cd - 回到之前目录</li>
<li>希望后期的Vim版本能优化这一问题</li>
</ul>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="技巧119-根据上下文自动补全"><a class="header" href="#技巧119-根据上下文自动补全">技巧119-根据上下文自动补全</a></h1>
<p>全能补全时由Vim实现的intellsense功能。</p>
<ul>
<li>intellsense 是 Intelligent Sense的缩写，指的是一套编程环境。</li>
<li>intellsense通过减少程序员常犯的误解、笔误以及其他错误，帮助他们加快编码的流程。</li>
</ul>
<p>全能补全功能可以通过<C-x><C-o>命令进行触发。</p>
<ul>
<li>参见:h compl-omni</li>
<li>实际上该功能由专用的文件类型插件实现，因此，必须先加载以下配置行。</li>
<li>essential.vim</li>
</ul>
<pre><code>set nocompatible
filetype plugin on
</code></pre>
<p>此外，还必须安装一个为所用语言实现全能补全功能的插件。</p>
<ul>
<li>Vim的发行版本身就支持十几种语言，包括:HTML、CSS、Javascript、PHP、以及SQL。</li>
<li>可以通过:h compl-omni-filetypes 找到完整的支持语言列表。</li>
</ul>
<p>CSS相对静态的语法特性决定了其非常适合采用全能补全功能。</p>
<h2 id="自己写一个全能补全插件"><a class="header" href="#自己写一个全能补全插件">自己写一个全能补全插件</a></h2>
<pre><code>:h complete-functions
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="技巧120-对你的工作进行拼写检查"><a class="header" href="#技巧120-对你的工作进行拼写检查">技巧120-对你的工作进行拼写检查</a></h1>
<ul>
<li>当拼写检查启用后，Vim将对所有未在拼写文件中出现过的单词进行标记。可以在这些拼写错误项之间快速跳转，并让Vim提供更正建议。</li>
<li><code>:set spell</code> 拼写检查错误处会语法高亮。</li>
<li>在缺省情况下，Vim将用包含英文单词的字典进行拼写检查。</li>
</ul>
<h2 id="操作vim的拼写检查器"><a class="header" href="#操作vim的拼写检查器">操作Vim的拼写检查器</a></h2>
<div class="table-wrapper"><table><thead><tr><th style="text-align: left">命令</th><th style="text-align: left">用途</th></tr></thead><tbody>
<tr><td style="text-align: left">]s</td><td style="text-align: left">跳到下一处拼写错误</td></tr>
<tr><td style="text-align: left">[s</td><td style="text-align: left">跳到上一处拼写错误</td></tr>
<tr><td style="text-align: left">z=</td><td style="text-align: left">为当前单词提供更正建议</td></tr>
<tr><td style="text-align: left">zg</td><td style="text-align: left">把当前单词添加到拼写文件中</td></tr>
<tr><td style="text-align: left">zw</td><td style="text-align: left">把当前单词从拼写文件中删除</td></tr>
<tr><td style="text-align: left">zug</td><td style="text-align: left">撤销针对当前单词的zg或zw命令</td></tr>
</tbody></table>
</div><div style="break-before: page; page-break-before: always;"></div><h1 id="技巧121-使用其他拼写字典"><a class="header" href="#技巧121-使用其他拼写字典">技巧121-使用其他拼写字典</a></h1>
<ul>
<li>一旦启用了Vim的拼写检查器，它将以英语字典作为默认的拼写字典进行单词比较。</li>
<li>通过配置spelllang选项，可以更改其默认设置。</li>
<li>spellang选项并不是全局性的，它永远只在本地缓冲区生效。</li>
<li>这意味着在编辑2各或2各以上的文档时，可以分别采用不同的拼写文件。</li>
</ul>
<h2 id="指定某个语言的区域性变体"><a class="header" href="#指定某个语言的区域性变体">指定某个语言的区域性变体</a></h2>
<ul>
<li>Vim的拼写文件本身就支持英语的几种区域性变体。</li>
<li>默认设置spelllang=en</li>
<li>意味着所有被以英语为母语的地区所认可的单词都是合法的。</li>
<li>无论输入的是英式拼法还是美式拼法，Vim的拼写检查器都认为时正确的。</li>
<li>可以指示Vim只接受美式拼法。</li>
</ul>
<pre><code>:set spell
:set spellang=en_us
</code></pre>
<h2 id="获取其他语言的拼写文件"><a class="header" href="#获取其他语言的拼写文件">获取其他语言的拼写文件</a></h2>
<ul>
<li>Vim的发行版本内置了支持英语的拼写文件。</li>
<li>可以到:http://ftp.vim.org/vim/runtime/spell/下载它支持的其他几十种语言的拼写文件。</li>
<li>如果试着加载某个尚未得到系统支持的拼写文件，Vim会提供下载安装的方法。
<ul>
<li>该功能由一个名为spellfile.vim的插件实现。(:h spellfile.vim)</li>
<li>激活该插件需要在.vimrc中配置:</li>
</ul>
</li>
</ul>
<pre><code>set nocompatible
plugin on
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="技巧122-将单词添加到拼写文件中"><a class="header" href="#技巧122-将单词添加到拼写文件中">技巧122-将单词添加到拼写文件中</a></h1>
<p>Vim的拼写字典并非十全十美，但可以通过把单词添加到拼写文件的方式来进一步完善它。</p>
<ul>
<li>可以用zg命令把光标下的单词加到拼写文件中，使Vim可以识别它。</li>
<li>zw命令，可以把光标所在处的单词标记为拼写错误。该命令把该单词从拼写文件中删除。</li>
<li>zug 可用于无意中添加或删除了单词到拼写文件中的情况。可以撤销对光标下单词所执行的zg或zw命令。</li>
</ul>
<p>Vim会把添加到字典中的单词保存至某个拼写文件中。拼写文件名字由所使用的语言以及文件编码类型决定。</p>
<ul>
<li>例如编辑的时一个UTF-8文件，采用的时英语字典，通过zg命令添加的单词都会被保存到：</li>
</ul>
<pre><code>~/.vim/spell/en.utf-8.add
</code></pre>
<h2 id="为专业术语创建拼写文件"><a class="header" href="#为专业术语创建拼写文件">为专业术语创建拼写文件</a></h2>
<p>通过配置spellfile选项，可以指定一个文件路径，用于保存由zg和zw命令添加、删除的单词。</p>
<ul>
<li>:h spellfile 查看帮助</li>
</ul>
<p>Vim允许同时指定多个拼写文件，这意味着可以维护多份单词列表。</p>
<ul>
<li>例如，当准备为某个章节进行拼写检查时，就可以将包含以下配置行的文件加载进来。</li>
<li>其中jargon.utf-8.add指向本书代码库中的一个文件，它保存了作者维护的Vim术语表。</li>
</ul>
<pre><code>setlocal spellang=en_us
setlocal spellfile=~/.vim/spell/en.utf-8.add
setlocal spellfile+=~/books/practical_vim/jargon.utf-8.add
</code></pre>
<p>对于每一个别拼写检查器误判的单词，目前都有两种方式处理：</p>
<ul>
<li>通过2zg将其添加到Vim术语表中</li>
<li>通过1zg将其添加到默认的单词列表中</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="技巧123-在插入模式下更正拼写错误"><a class="header" href="#技巧123-在插入模式下更正拼写错误">技巧123-在插入模式下更正拼写错误</a></h1>
<h2 id="通常做法切换到普通模式"><a class="header" href="#通常做法切换到普通模式">通常做法:切换到普通模式</a></h2>
<pre><code>[s 命令跳回到发生拼写错误的地方
1z= 将其更正过来
</code></pre>
<h2 id="快捷方式利用拼写自动补全功能"><a class="header" href="#快捷方式利用拼写自动补全功能">快捷方式:利用拼写自动补全功能</a></h2>
<ul>
<li>在插入模式下通过<code>&lt;C-x&gt;s</code>命令更正拼写错误。</li>
<li>还可以通过<code>&lt;C-x&gt;&lt;C-s&gt;</code>实现同样的功能（与<code>&lt;C-x&gt;s</code>有细节区别)。</li>
<li>只有某行文本出现的拼写错误不止一处时，<code>&lt;C-x&gt;s</code>命令才能发挥处其优势。如果处于插入模式，光标位于行末，由2处拼写错误，只需要2此输入<code>&lt;C-x&gt;s</code>，就可以将2处拼写错误更正回来。</li>
</ul>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
            </nav>

        </div>

        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>
    </body>
</html>
